//! Define the structures required in SNARKs for Bit Decomposition
use algebra::{DenseMultilinearExtension, Field, MultilinearExtension};
use std::marker::PhantomData;
use std::rc::Rc;

use crate::bit_decomposition::eval_identity_function;
use crate::sumcheck::prover::ProverMsg;

/// SNARKs for bit decomposition
pub struct BitDecomposition<F: Field>(#[doc(hidden)] PhantomData<F>);

/// proof generated by prover
pub struct BitDecompositionProof<F: Field> {
    pub(crate) sumcheck_msg: Vec<ProverMsg<F>>,
}

/// subclaim returned to verifier
pub struct BitDecompositionSubClaim<F: Field> {
    /// r
    pub randomness: Vec<F>,
    /// v
    pub v: Vec<F>,
    /// expected value returned in sumcheck
    pub expected_evaluation: F,
}

/// Stores the parameters used for bit decomposation.
///
/// * It is required to decompose over a power-of-2 base.
/// The resulting decomposed bits are used as the prover key.
pub struct DecomposedBits<F: Field> {
    /// base
    pub base: F,
    /// base = 2^base_bits
    pub base_bits: u32,
    /// length of the decomposed bits
    pub len_bits: u32,
    /// number of variables of every polynomial
    pub num_variables: usize,
    /// Plain deomposed bits
    pub decomposed_bits: Vec<Rc<DenseMultilinearExtension<F>>>,
}

impl<F: Field> DecomposedBits<F> {
    /// Extract the information of decomposed bits for verification
    pub fn info(&self) -> DecomposedBitsInfo<F> {
        DecomposedBitsInfo {
            base: self.base,
            base_bits: self.base_bits,
            len_bits: self.len_bits,
            num_variables: self.num_variables,
        }
    }
}

/// Stores the parameters used for bit decomposation.
///
/// It is required to decompose over a power-of-2 base.
/// These parameters are used as the verifier key.
pub struct DecomposedBitsInfo<F: Field> {
    /// base
    pub base: F,
    /// base = 2^base_bits
    pub base_bits: u32,
    /// length of the decomposed bits
    pub len_bits: u32,
    /// number of variables of every polynomial
    pub num_variables: usize,
}

impl<F: Field> BitDecompositionSubClaim<F> {
    /// verify the subclaim
    pub fn verify_subclaim(
        &self,
        d: &DenseMultilinearExtension<F>,
        d_i: &Vec<DenseMultilinearExtension<F>>,
        u: &[F],
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> bool {
        let len: usize = decomposed_bits_info.len_bits as usize;
        assert_eq!(len, d_i.len());
        assert_eq!(len, self.randomness.len());
        let dim = u.len();
        assert_eq!(dim, self.v.len());
        assert_eq!(dim, d.num_vars);
        for poly in d_i {
            assert_eq!(dim, poly.num_vars);
        }

        // check 1: d[v] = \sum_{i=0}^len B^i \cdot d_i[v]
        let eval_d = d.evaluate(&self.v);
        let eval_d_i: Vec<F> = d_i.iter().map(|x| x.evaluate(&self.v)).collect();

        let mut sum = F::ZERO;
        let mut pow_base = F::ONE;
        for bit in &eval_d_i {
            sum += *bit * pow_base;
            pow_base *= decomposed_bits_info.base;
        }
        if eval_d != sum {
            return false;
        }

        // check 2: expected value returned in sumcheck
        let mut eval = F::zero();
        for (bit, r) in eval_d_i.iter().zip(&self.randomness) {
            let mut prod = *r;
            let mut k_as_filed = F::ZERO;
            for _ in 0..(1 << decomposed_bits_info.base_bits) {
                prod *= *bit - k_as_filed;
                k_as_filed += F::one();
            }
            eval += prod;
        }

        self.expected_evaluation == eval * eval_identity_function(u, &self.v)
    }
}
