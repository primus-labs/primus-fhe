//! PIOP for Addition in Zq
//! The prover wants to convince that the addition in Zq in a larger modulus Q.
//! * q: the modulus used in the addition
//!
//! Given M instances of addition in Zq, the main idea of this IOP is to prove:
//! For x \in \{0, 1\}^l
//! 1. a(x), b(c), c(x) \in \[q\] => these range check can be batchly proved by the Bit Decomposition IOP
//! 2. k(x) \cdot (1 - k(x)) = 0  => can be reduced to prove the sum
//!     $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [k(x) \cdot (1 - k(x))] = 0$
//!     where u is the common random challenge from the verifier, used to instantiate the sum,
//!     and then, it can be proved with the sumcheck protocol where the maximum variable-degree is 3.
//! 3. a(x) + b(x) = c(x) + k(x)\cdot q => can be reduced to the evaluation of a random point since the LHS and RHS are both MLE
use algebra::{
    AbstractExtensionField, DecomposableField, DenseMultilinearExtension, Field,
    ListOfProductsOfPolynomials, MultilinearExtension, PolynomialInfo,
    utils::Transcript,
};
use crate::sumcheck::{prover::ProverState, verifier::SubClaim, MLSumcheck, Proof};
use crate::utils::{
    eval_identity_function, gen_identity_evaluations, print_statistic, verify_oracle_relation,
};
use pcs::{
    multilinear::brakedown::BrakedownPCS,
    utils::code::{LinearCode, LinearCodeSpec},
    utils::hash::Hash,
    PolynomialCommitmentScheme,
};
use core::fmt;
use itertools::izip;
use serde::{Deserialize, Serialize};
use std::marker::PhantomData;
use std::rc::Rc;
use std::time::Instant;

use super::bit_decomposition::DecomposedBitsEval;
use super::{BitDecomposition, DecomposedBits, DecomposedBitsInfo};

/// SNARKs for addition in Zq, i.e. a + b = c (mod q)
pub struct AdditionInZq<F: Field>(PhantomData<F>);

/// proof generated by prover
// pub struct AdditionInZqProof<F: Field> {
//     /// batched rangecheck proof for a, b, c \in Zq
//     pub rangecheck_msg: BitDecompositionProof<F>,
//     /// sumcheck proof for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
//     pub sumcheck_msg: Vec<ProverMsg<F>>,
// }

/// subclaim returned to verifier
// pub struct AdditionInZqSubclaim<F: Field> {
//     /// rangecheck subclaim for a, b, c \in Zq
//     pub(crate) rangecheck_subclaim: BitDecompositionSubClaim<F>,
//     /// subcliam for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0
//     pub sumcheck_point: Vec<F>,
//     /// expected value returned in the last round of the sumcheck
//     pub sumcheck_expected_evaluations: F,
// }

/// Stores the parameters used for addition in Zq and the inputs and witness for prover.
pub struct AdditionInZqInstance<F: Field> {
    /// modulus in addition
    pub q: F,
    /// number of variables
    pub num_vars: usize,
    /// inputs a, b, and c
    pub abc: Vec<Rc<DenseMultilinearExtension<F>>>,
    /// introduced witness k
    pub k: Rc<DenseMultilinearExtension<F>>,
    /// introduced witness to check the range of a, b, c
    pub abc_bits: Vec<Rc<DenseMultilinearExtension<F>>>,
    /// info for decomposed bits
    pub bits_info: DecomposedBitsInfo<F>,
}

/// Evaluations of all MLEs involed in the instance at a random point
pub struct AdditionInZqInstanceEval<F: Field> {
    /// inputs a, b, and c
    pub abc: Vec<F>,
    /// introduced witness k
    pub k: F,
    /// introduced witness to check the range of a, b, c
    pub abc_bits: Vec<F>,
}

/// Stores the parameters used for addition in Zq and the public info for verifier.
pub struct AdditionInZqInstanceInfo<F: Field> {
    /// modulus in addition
    pub q: F,
    /// number of variables
    pub num_vars: usize,
    /// Decomposition info for range check (i.e. bit decomposition)
    pub bits_info: DecomposedBitsInfo<F>,
}

impl<F: Field> AdditionInZqInstance<F> {
    /// Extract the information of addition in Zq for verification
    #[inline]
    pub fn info(&self) -> AdditionInZqInstanceInfo<F> {
        AdditionInZqInstanceInfo {
            q: self.q,
            num_vars: self.num_vars,
            bits_info: self.bits_info.clone(),
        }
    }

    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // number of value oracle + number of decomposed bits oracle
        assert_eq!(self.abc.len(), 3);
        assert_eq!(self.abc_bits.len(), 3 * self.bits_info.bits_len as usize);
        self.abc.len() + 1 + self.abc_bits.len()
    }

    /// Return the log of the number of small polynomials used in IOP
    #[inline]
    pub fn log_num_oracles(&self) -> usize {
        self.num_oracles().next_power_of_two().ilog2() as usize
    }

    /// Pack all the involved small polynomials into a single vector of evaluations without padding zeros.
    pub fn pack_all_mles(&self) -> Vec<F> {
        // arrangement: abc || k || abc_bits
        self.abc
            .iter()
            .flat_map(|v| v.iter())
            .chain(self.k.iter())
            .chain(self.abc_bits.iter().flat_map(|bit| bit.iter()))
            .copied()
            .collect::<Vec<F>>()
    }

    /// Generate the oracle to be committed that is composed of all the small oracles used in IOP.
    /// The evaluations of this oracle is generated by the evaluations of all mles and the padded zeros.
    /// The arrangement of this oracle should be consistent to its usage in verifying the subclaim.
    pub fn generate_oracle(&self) -> DenseMultilinearExtension<F> {
        let num_vars_added = self.log_num_oracles();
        let num_vars = self.num_vars + num_vars_added;
        let num_zeros_padded = ((1 << num_vars_added) - self.num_oracles()) * (1 << self.num_vars);

        // arrangement: all values||all decomposed bits||padded zeros
        let mut evals = self.pack_all_mles();
        evals.append(&mut vec![F::zero(); num_zeros_padded]);
        <DenseMultilinearExtension<F>>::from_evaluations_vec(num_vars, evals)
    }

    /// Construct a EF version
    pub fn to_ef<EF: AbstractExtensionField<F>>(&self) -> AdditionInZqInstance<EF> {
        AdditionInZqInstance::<EF> {
            q: EF::from_base(self.q),
            num_vars: self.num_vars,
            abc: self.abc.iter().map(|v| Rc::new(v.to_ef())).collect(),
            k: Rc::new(self.k.to_ef()),
            abc_bits: self
                .abc_bits
                .iter()
                .map(|bit| Rc::new(bit.to_ef()))
                .collect(),
            bits_info: DecomposedBitsInfo::<EF> {
                base: EF::from_base(self.bits_info.base),
                base_len: self.bits_info.base_len,
                bits_len: self.bits_info.bits_len,
                num_vars: self.bits_info.num_vars,
                num_instances: self.bits_info.num_instances,
            },
        }
    }

    /// Evaluate at a random point defined over Field
    #[inline]
    pub fn evaluate(&self, point: &[F]) -> AdditionInZqInstanceEval<F> {
        AdditionInZqInstanceEval::<F> {
            abc: self.abc.iter().map(|v| v.evaluate(point)).collect(),
            k: self.k.evaluate(point),
            abc_bits: self
                .abc_bits
                .iter()
                .map(|bit| bit.evaluate(point))
                .collect(),
        }
    }

    /// Evaluate at a random point defined over Extension Field
    #[inline]
    pub fn evaluate_ext<EF: AbstractExtensionField<F>>(
        &self,
        point: &[EF],
    ) -> AdditionInZqInstanceEval<EF> {
        AdditionInZqInstanceEval::<EF> {
            abc: self.abc.iter().map(|v| v.evaluate_ext(point)).collect(),
            k: self.k.evaluate_ext(point),
            abc_bits: self
                .abc_bits
                .iter()
                .map(|bit| bit.evaluate_ext(point))
                .collect(),
        }
    }

    /// Extract DecomposedBits instance
    #[inline]
    pub fn extract_decomposed_bits(&self) -> DecomposedBits<F> {
        DecomposedBits {
            base: self.bits_info.base,
            base_len: self.bits_info.base_len,
            bits_len: self.bits_info.bits_len,
            num_vars: self.num_vars,
            d_val: self.abc.to_owned(),
            d_bits: self.abc_bits.to_owned(),
        }
    }
}

impl<F: Field> AdditionInZqInstanceEval<F> {
    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // number of value oracle + number of decomposed bits oracle
        self.abc.len() + 1 + self.abc_bits.len()
    }

    /// Return the log of the number of small polynomials used in IOP
    #[inline]
    pub fn log_num_oracles(&self) -> usize {
        self.num_oracles().next_power_of_two().ilog2() as usize
    }

    /// Flatten all evals into a vector with the same arrangement of the committed polynomial
    #[inline]
    pub fn flatten(&self) -> Vec<F> {
        let mut res = Vec::with_capacity(self.num_oracles());
        res.extend(self.abc.iter());
        res.push(self.k);
        res.extend(self.abc_bits.iter());
        res
    }

    /// Extract DecomposedBitsEval instance
    #[inline]
    pub fn extract_decomposed_bits(&self) -> DecomposedBitsEval<F> {
        DecomposedBitsEval {
            d_val: self.abc.to_owned(),
            d_bits: self.abc_bits.to_owned(),
        }
    }
}

impl<F: DecomposableField> AdditionInZqInstance<F> {
    /// Construct a new instance from vector
    // #[inline]
    // pub fn from_vec(
    //     abc: Vec<Rc<DenseMultilinearExtension<F>>>,
    //     k: &Rc<DenseMultilinearExtension<F>>,
    //     q: F,
    //     base: F,
    //     base_len: u32,
    //     bits_len: u32,
    // ) -> Self {
    //     let num_vars = k.num_vars;
    //     assert_eq!(abc.len(), 3);
    //     for x in &abc {
    //         assert_eq!(x.num_vars, num_vars);
    //     }

    //     let abc_bits = abc
    //         .iter()
    //         .map(|x| x.get_decomposed_mles(base_len, bits_len))
    //         .flatten()
    //         .collect::<Vec<_>>();
    //     Self {
    //         q,
    //         num_vars,
    //         abc,
    //         k: Rc::clone(k),
    //         abc_bits: DecomposedBits {
    //             base,
    //             base_len,
    //             bits_len,
    //             num_vars,
    //             d_val: abc,
    //             d_bits: abc_bits,
    //         },
    //     }
    // }

    /// Construct a new instance from slice
    #[inline]
    pub fn from_slice(
        abc: &[Rc<DenseMultilinearExtension<F>>],
        k: &Rc<DenseMultilinearExtension<F>>,
        q: F,
        bits_info: &DecomposedBitsInfo<F>,
    ) -> Self {
        let num_vars = k.num_vars;
        assert_eq!(abc.len(), 3);
        assert_eq!(bits_info.num_instances, 3);
        for x in abc {
            assert_eq!(x.num_vars, num_vars);
        }

        let abc_bits = abc
            .iter()
            .flat_map(|x| x.get_decomposed_mles(bits_info.base_len, bits_info.bits_len))
            .collect();

        Self {
            q,
            num_vars,
            abc: abc.to_owned(),
            k: Rc::clone(k),
            abc_bits,
            bits_info: bits_info.clone(),
        }
    }
}

// impl<F: Field> AdditionInZqSubclaim<F> {
//     /// verify the sumcliam
//     /// * abc stores the inputs and the output to be added in Zq
//     /// * k stores the introduced witness s.t. a + b = c + k\cdot q
//     /// * abc_bits stores the decomposed bits for a, b, and c
//     /// * u is the common random challenge from the verifier, used to instantiate the sumcheck.
//     #[inline]
//     pub fn verify_subclaim(
//         &self,
//         q: F,
//         abc: &[Rc<DenseMultilinearExtension<F>>],
//         k: &DenseMultilinearExtension<F>,
//         abc_bits: &[&Vec<Rc<DenseMultilinearExtension<F>>>],
//         u: &[F],
//         info: &AdditionInZqInstanceInfo<F>,
//     ) -> bool {
//         assert_eq!(abc.len(), 3);
//         assert_eq!(abc_bits.len(), 3);

//         // check 1: subclaim for rangecheck, i.e. a, b, c \in [Zq]
//         if !self
//             .rangecheck_subclaim
//             .verify_subclaim(abc, abc_bits, u, &info.decomposed_bits_info)
//         {
//             return false;
//         }

//         // check 2: subclaim for sumcheck, i.e. eq(u, point) * k(point) * (1 - k(point)) = 0
//         let eval_k = k.evaluate(&self.sumcheck_point);
//         if eval_identity_function(u, &self.sumcheck_point) * eval_k * (F::one() - eval_k)
//             != self.sumcheck_expected_evaluations
//         {
//             return false;
//         }

//         // check 3: a(u) + b(u) = c(u) + k(u) * q
//         abc[0].evaluate(u) + abc[1].evaluate(u) == abc[2].evaluate(u) + k.evaluate(u) * q
//     }
// }

impl<F: Field + Serialize> AdditionInZq<F> {
    /// sample coins before proving sumcheck protocol
    pub fn sample_coins(trans: &mut Transcript<F>, instance: &AdditionInZqInstance<F>) -> Vec<F> {
        let bits_instance = instance.extract_decomposed_bits();
        // batch `len_bits` sumcheck protocols into one with random linear combination
        trans.get_vec_challenge(
            b"randomness to combine sumcheck protocols",
            <BitDecomposition<F>>::num_coins(&bits_instance.info()) + 1,
        )
    }

    /// return the number of coins used in this IOP
    pub fn num_coins(info: &AdditionInZqInstanceInfo<F>) -> usize {
        <BitDecomposition<F>>::num_coins(&info.bits_info) + 1
    }

    /// Prove addition in Zq given a, b, c, k, and the decomposed bits for a, b, and c.
    pub fn prove(
        instance: &AdditionInZqInstance<F>,
    ) -> (Proof<F>, ProverState<F>, PolynomialInfo) {
        let mut trans = Transcript::<F>::new();
        let u = trans.get_vec_challenge(
            b"random point used to instantiate sumcheck protocol",
            instance.num_vars,
        );

        let mut poly = ListOfProductsOfPolynomials::<F>::new(instance.num_vars);
        let randomness = Self::sample_coins(&mut trans, &instance);
        Self::prove_as_subprotocol(&randomness, &mut poly, &instance, &u);
        
        let (proof, state) = MLSumcheck::prove_as_subprotocol(&mut trans, &poly)
            .expect("fail to prove the sumcheck protocol");
        (proof, state, poly.info())
    }


    /// Prove addition in Zq given a, b, c, k, and the decomposed bits for a, b, and c.
    pub fn prove_as_subprotocol(
        randomness: &[F],
        poly: &mut ListOfProductsOfPolynomials<F>,
        instance: &AdditionInZqInstance<F>,
        u: &[F],
    ) {
        let bits_instance = instance.extract_decomposed_bits();
        let bits_info = bits_instance.info();
        let bits_r_num = <BitDecomposition<F>>::num_coins(&bits_info);
        // 1. add products of poly used to prove decomposition
        BitDecomposition::prove_as_subprotocol(&randomness[..bits_r_num], poly, &bits_instance, u);

        // 2. sumcheck for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
        let coin = randomness[randomness.len() - 1];
        poly.add_product_with_linear_op(
            [
                Rc::new(gen_identity_evaluations(u)),
                Rc::clone(&instance.k),
                Rc::clone(&instance.k),
            ],
            &[
                (F::one(), F::zero()),
                (F::one(), F::zero()),
                (-F::one(), F::one()),
            ],
            coin,
        );
    }

    // pub fn prove_as_subprotocol_<EF: AbstractExtensionField<F>>(
    //     fs_rng: &mut impl RngCore,
    //     poly: &mut ListOfProductsOfPolynomials<EF>,
    //     addition_instance: &AdditionInZqInstance<F>,
    //     u: &[F],
    // ) -> AdditionInZqProof<F> {
    //     // 1. rangecheck
    //     let rangecheck_msg =
    //         BitDecomposition::prove_as_subprotocol(fs_rng, &addition_instance.abc_bits, u);

    //     let dim = u.len();
    //     assert_eq!(dim, addition_instance.num_vars);
    //     let mut poly = <ListOfProductsOfPolynomials<F>>::new(dim);

    //     // 2. execute sumcheck for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
    //     let mut product = Vec::with_capacity(3);
    //     let mut op_coefficient = Vec::with_capacity(3);
    //     product.push(Rc::new(gen_identity_evaluations(u)));
    //     op_coefficient.push((F::one(), F::zero()));

    //     product.push(Rc::clone(&addition_instance.k));
    //     op_coefficient.push((F::one(), F::zero()));
    //     product.push(Rc::clone(&addition_instance.k));
    //     op_coefficient.push((-F::one(), F::one()));

    //     poly.add_product_with_linear_op(product, &op_coefficient, F::one());
    //     let sumcheck_proof = MLSumcheck::prove_as_subprotocol(fs_rng, &poly)
    //         .expect("sumcheck for addition in Zq failed");

    //     AdditionInZqProof {
    //         rangecheck_msg,
    //         sumcheck_msg: sumcheck_proof.0,
    //     }
    // }

    /// Verify addition in Zq 
    pub fn verify(
        proof: &Proof<F>,
        poly_info: &PolynomialInfo,
        evals: &AdditionInZqInstanceEval<F>,
        info: &AdditionInZqInstanceInfo<F>,
    ) -> bool {
        let mut trans = Transcript::new();

        let u = trans.get_vec_challenge(
            b"random point used to instantiate sumcheck protocol",
            info.num_vars,
        );

        // randomness to combine sumcheck protocols
        let randomness = trans.get_vec_challenge(
            b"randomness to combine sumcheck protocols",
            Self::num_coins(info),
        );

        let mut subclaim =
            MLSumcheck::verify_as_subprotocol(&mut trans, &poly_info, F::zero(), &proof)
                .expect("fail to verify the sumcheck protocol");

        if !Self::verify_as_subprotocol(&randomness, &mut subclaim, evals, info, &u) {
            return false;
        }

        subclaim.expected_evaluations == F::zero()
    }
    
    /// Verify addition in Zq
    pub fn verify_as_subprotocol(
        randomness: &[F],
        subclaim: &mut SubClaim<F>,
        evals: &AdditionInZqInstanceEval<F>,
        info: &AdditionInZqInstanceInfo<F>,
        u: &[F],
    ) -> bool {
        // check 1: Verify the range check part in the sumcheck polynomial
        let bits_evals = evals.extract_decomposed_bits();
        let bits_randomness = &randomness[..<BitDecomposition<F>>::num_coins(&info.bits_info)];
        let check_decomposed_bits = <BitDecomposition<F>>::verify_as_subprotocol(&bits_randomness, subclaim, &bits_evals, &info.bits_info, u);
        if !check_decomposed_bits {
            return false;
        }
        // check 2: a(u) + b(u) = c(u) + k(u) * q
        if evals.abc[0] + evals.abc[1] != evals.abc[2] + evals.k * info.q {
            return false;
        }

        // check 3: Verify the newly added part in the sumcheck polynomial
        let coin = randomness[randomness.len() - 1];
        subclaim.expected_evaluations -= coin * eval_identity_function(u, &subclaim.point) * evals.k * (F::one() - evals.k);
        true
    }
}