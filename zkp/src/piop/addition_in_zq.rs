//! PIOP for Addition in Zq
//! The prover wants to convince that the addition in Zq in a larger modulus Q.
//! * q: the modulus used in the addition
//!
//! Given M instances of addition in Zq, the main idea of this IOP is to prove:
//! For x \in \{0, 1\}^l
//! 1. a(x), b(c), c(x) \in \[q\] => these range check can be batchly proved by the Bit Decomposition IOP
//! 2. k(x) \cdot (1 - k(x)) = 0  => can be reduced to prove the sum
//!     $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [k(x) \cdot (1 - k(x))] = 0$
//!     where u is the common random challenge from the verifier, used to instantiate the sum,
//!     and then, it can be proved with the sumcheck protocol where the maximum variable-degree is 3.
//! 3. a(x) + b(x) = c(x) + k(x)\cdot q => can be reduced to the evaluation of a random point since the LHS and RHS are both MLE

use core::fmt;
use std::marker::PhantomData;
use std::rc::Rc;

use super::bit_decomposition::{
    BitDecompositionProof, BitDecompositionSubClaim, DecomposedBits, DecomposedBitsInfo,
};
use crate::sumcheck::prover::ProverMsg;
use crate::utils::eval_identity_function;
use crate::{piop::BitDecomposition, sumcheck::verifier::SubClaim};

use crate::sumcheck::MLSumcheck;
use crate::utils::gen_identity_evaluations;
use algebra::{
    utils::Transcript, AbstractExtensionField, DecomposableField, DenseMultilinearExtension,
    DenseMultilinearExtensionBase, ExtensionField, Field, ListOfProductsOfPolynomials, Packable,
    PolynomialInfo, UF,
};
use serde::Serialize;

/// SNARKs for addition in Zq, i.e. a + b = c (mod q)
pub struct AdditionInZq<F: Field, EF: AbstractExtensionField<F>> {
    _marker: PhantomData<F>,
    _stone: PhantomData<EF>,
}

/// proof generated by prover
#[derive(Serialize)]
pub struct AdditionInZqProof<F: Field, EF: AbstractExtensionField<F>> {
    /// batched rangecheck proof for a, b, c \in Zq
    pub rangecheck_msg: BitDecompositionProof<F, EF>,
    /// sumcheck proof for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
    pub sumcheck_msg: Vec<ProverMsg<F, EF>>,
}

/// subclaim returned to verifier
pub struct AdditionInZqSubclaim<F: Field, EF: AbstractExtensionField<F>> {
    /// rangecheck subclaim for a, b, c \in Zq
    pub(crate) rangecheck_subclaim: BitDecompositionSubClaim<F, EF>,
    /// subcliam for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0
    pub sumcheck_point: Vec<EF>,
    /// expected value returned in the last round of the sumcheck
    pub sumcheck_expected_evaluations: EF,
}

/// Stores the parameters used for addition in Zq and the inputs and witness for prover.
pub struct AdditionInZqInstance<F: Field> {
    /// modulus in addition
    pub q: F,
    /// number of variables
    pub num_vars: usize,
    /// inputs a, b, and c
    pub abc: Vec<Rc<DenseMultilinearExtensionBase<F>>>,
    /// introduced witness k
    pub k: Rc<DenseMultilinearExtensionBase<F>>,
    /// introduced witness to check the range of a, b, c
    pub abc_bits: DecomposedBits<F>,
}

/// Store the corresponding MLE of AdditionInZqInstance where the evaluations are over the extension field.
pub struct AdditionInZqInstanceExt<F: Field, EF: AbstractExtensionField<F>> {
    /// introduced witness k
    pub k: Rc<DenseMultilinearExtension<F, EF>>,
}

impl<F: Field, EF: AbstractExtensionField<F>> AdditionInZqInstanceExt<F, EF> {
    /// Construct an instance over the extension field from the original instance defined over the basic field
    pub fn from_base(input_base: &AdditionInZqInstance<F>) -> Self {
        Self {
            k: Rc::new(<DenseMultilinearExtension<F, EF>>::from_base(
                input_base.k.as_ref(),
            )),
        }
    }
}

/// Stores the parameters used for addition in Zq and the public info for verifier.
#[derive(Serialize)]
pub struct AdditionInZqInstanceInfo<F: Field> {
    /// modulus in addition
    pub q: F,
    /// Decomposition info for range check (i.e. bit decomposition)
    pub decomposed_bits_info: DecomposedBitsInfo<F>,
}

impl<F: Field> AdditionInZqInstanceInfo<F> {
    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // 1 is for the `k` oracle
        self.decomposed_bits_info.num_oracles() + 1
    }

    /// Return the number of random coefficient sampled to randomize sumcheck protocols
    #[inline]
    pub fn num_randomness(&self) -> usize {
        self.decomposed_bits_info.num_coins() + 1
    }

    /// Compute the evaluation over the random point of the polynomial proved in the sumcheck protocol
    #[inline]
    pub fn subclaim_real_eval<EF: AbstractExtensionField<F>>(
        &self,
        evals: &[EF],
        u: &[EF],
        r: &[EF],
        subclaim: &SubClaim<F, EF>,
    ) -> EF {
        let num_oracles = self.decomposed_bits_info.num_oracles();
        let num_r = self.decomposed_bits_info.num_coins();

        let k_eval = evals[evals.len() - 1];
        let k_r = r[r.len() - 1];
        // the evaluation is divided by two parts, each corresponding one sumcheck protocol
        self.decomposed_bits_info.compute_subclaim_eval(
            &evals[..num_oracles],
            u,
            &r[..num_r],
            subclaim,
        ) + k_r * eval_identity_function(u, &subclaim.point) * k_eval * (EF::one() - k_eval)
    }

    /// Verify the subclaim using the evalustions sent by the prover instead of the whole MLEs.
    /// This interface is the corresponding version of the `verify_subclaim`, which takes many MLEs as input.
    ///
    /// # Argument
    ///
    /// * `evals`: vector consisting of all the evaluations of relevant MLEs. The arrangement is consistent to the vector returned in `subclaim_real_eval`.
    #[inline]
    pub fn verify_subclaim<EF: AbstractExtensionField<F>>(
        &self,
        evals: &[EF],
        u: &[EF],
        randomness: &[EF],
        subclaim: &SubClaim<F, EF>,
    ) -> bool {
        // check 1:  a(r) + b(r) = c(r) + k(r) * q
        // arrangement of evals: (abc_bits) || k
        // arrangement of evals regarding abc_bits part: all values || all decomposed bits
        let a_eval = evals[0];
        let b_eval = evals[1];
        let c_eval = evals[2];
        let k_eval = evals[evals.len() - 1];
        if a_eval + b_eval != c_eval + k_eval * self.q {
            return false;
        }

        // check 2: check the evaluation of the polynomial proved in the sumcheck protocol
        self.subclaim_real_eval(evals, u, randomness, subclaim) == subclaim.expected_evaluations
    }
}

impl<F: Field> fmt::Display for AdditionInZqInstanceInfo<F> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(
            f,
            "An instance of Addition In Zq: #vars = {}, q = {}",
            self.decomposed_bits_info.num_vars, self.q,
        )?;
        write!(f, "- containing ")?;
        self.decomposed_bits_info.fmt(f)
    }
}

impl<F: Field> AdditionInZqInstance<F> {
    /// Extract the information of addition in Zq for verification
    #[inline]
    pub fn info(&self) -> AdditionInZqInstanceInfo<F> {
        AdditionInZqInstanceInfo {
            q: self.q,
            decomposed_bits_info: self.abc_bits.info(),
        }
    }

    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // 1 is for the `k` oracle
        self.abc_bits.num_oracles() + 1
    }
}

impl<F: DecomposableField> AdditionInZqInstance<F> {
    /// Construct a new instance from vector
    #[inline]
    pub fn from_vec(
        abc: Vec<Rc<DenseMultilinearExtensionBase<F>>>,
        k: &Rc<DenseMultilinearExtensionBase<F>>,
        q: F,
        base: F,
        base_len: u32,
        bits_len: u32,
    ) -> Self {
        let num_vars = k.num_vars;
        assert_eq!(abc.len(), 3);
        for x in &abc {
            assert_eq!(x.num_vars, num_vars);
        }

        let abc_bits = abc
            .iter()
            .map(|x| x.get_decomposed_mles(base_len, bits_len))
            .collect();
        Self {
            q,
            num_vars,
            abc,
            k: Rc::clone(k),
            abc_bits: DecomposedBits {
                base,
                base_len,
                bits_len,
                num_vars,
                d_bits: abc_bits,
            },
        }
    }

    /// Construct a new instance from slice
    #[inline]
    pub fn from_slice(
        abc: &[Rc<DenseMultilinearExtensionBase<F>>],
        k: &Rc<DenseMultilinearExtensionBase<F>>,
        q: F,
        base: F,
        base_len: u32,
        bits_len: u32,
    ) -> Self {
        let num_vars = k.num_vars;
        assert_eq!(abc.len(), 3);
        for x in abc {
            assert_eq!(x.num_vars, num_vars);
        }

        let abc_bits = abc
            .iter()
            .map(|x| x.get_decomposed_mles(base_len, bits_len))
            .collect();
        Self {
            q,
            num_vars,
            abc: abc.to_owned(),
            k: Rc::clone(k),
            abc_bits: DecomposedBits {
                base,
                base_len,
                bits_len,
                num_vars,
                d_bits: abc_bits,
            },
        }
    }

    /// Pack all the involved small polynomials into a single vector of evaluations without padding zeros.
    #[inline]
    pub fn pack_all_mles(&self) -> Vec<F> {
        assert_eq!(self.abc.len(), 3);
        assert_eq!(self.abc_bits.d_bits.len(), 3);
        // arragement: arrangement of decomposed bits (abc_bits) || k
        let mut evals = self.abc_bits.pack_all_mles(&self.abc);
        evals.extend(self.k.iter());
        evals
    }

    /// Generate the oracle to be committed that is composed of all the small oracles used in IOP.
    #[inline]
    pub fn generate_oracle(&self) -> DenseMultilinearExtensionBase<F> {
        // Oracles: abc, k, and abc_bits
        let num_oracles = self.num_oracles();
        let num_vars_added = num_oracles.next_power_of_two().ilog2() as usize;
        let num_vars = self.num_vars + num_vars_added;
        let num_zeros_padded = ((1 << num_vars_added) - num_oracles) * (1 << self.num_vars);

        // arragement: arrangement of decomposed bits (abc_bits) || k || padded zeros
        let mut evals = self.pack_all_mles();
        evals.append(&mut vec![F::zero(); num_zeros_padded]);
        <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(num_vars, evals)
    }

    /// Prover needs to compute the evaluations of all the smaller MLEs at the random point reduced from sumcheck protocol.
    #[inline]
    pub fn compute_evals<EF: AbstractExtensionField<F>>(&self, point: &[EF]) -> Vec<EF> {
        // arragement: arrangement of decomposed bits (abc_bits) || k
        let mut evals = self.abc_bits.compute_evals(&self.abc, point);
        evals.push(self.k.evaluate_ext(point));
        evals
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> AdditionInZqSubclaim<F, EF> {
    /// verify the sumcliam
    /// * abc stores the inputs and the output to be added in Zq
    /// * k stores the introduced witness s.t. a + b = c + k\cdot q
    /// * abc_bits stores the decomposed bits for a, b, and c
    /// * u is the common random challenge from the verifier, used to instantiate the sumcheck.
    #[inline]
    pub fn verify_subclaim(
        &self,
        q: F,
        abc: &[Rc<DenseMultilinearExtensionBase<F>>],
        k: &DenseMultilinearExtensionBase<F>,
        abc_bits: &[&Vec<Rc<DenseMultilinearExtensionBase<F>>>],
        u: &[EF],
        info: &AdditionInZqInstanceInfo<F>,
    ) -> bool {
        assert_eq!(abc.len(), 3);
        assert_eq!(abc_bits.len(), 3);

        // check 1: subclaim for rangecheck, i.e. a, b, c \in [Zq]
        if !self
            .rangecheck_subclaim
            .verify_subclaim(abc, abc_bits, u, &info.decomposed_bits_info)
        {
            return false;
        }

        // check 2: subclaim for sumcheck, i.e. eq(u, point) * k(point) * (1 - k(point)) = 0
        let eval_k = k.evaluate_ext(&self.sumcheck_point);
        if eval_identity_function(u, &self.sumcheck_point) * eval_k * (EF::one() - eval_k)
            != self.sumcheck_expected_evaluations
        {
            return false;
        }

        // check 3: a(u) + b(u) = c(u) + k(u) * q
        abc[0].evaluate_ext(u) + abc[1].evaluate_ext(u)
            == abc[2].evaluate_ext(u) + k.evaluate_ext(u) * q
    }
}

impl<F: Field + Packable, EF: ExtensionField<F>> AdditionInZq<F, EF> {
    /// Update the polynomial to be proved in the sumcheck protocol
    #[inline]
    pub fn random_poly(
        poly: &mut ListOfProductsOfPolynomials<F, EF>,
        trans: &mut Transcript<F>,
        instance: &AdditionInZqInstance<F>,
        random_u: &[EF],
    ) -> EF {
        let sum_added =
            <BitDecomposition<F, EF>>::random_poly(poly, trans, &instance.abc_bits, random_u);

        // Convert the MLE over Field in the original instance to a new instance containing the corresponding MLE over Extension Field
        let instance_ext = <AdditionInZqInstanceExt<F, EF>>::from_base(instance);

        // Combine a sumcheck for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l using random linear combination
        let random =
            trans.get_ext_field_challenge::<EF>(b"combine a sumcheck protocol in addition in zq");
        poly.add_product_with_linear_op(
            [
                Rc::new(gen_identity_evaluations(random_u)),
                Rc::clone(&instance_ext.k),
                Rc::clone(&instance_ext.k),
            ],
            &[
                (<UF<F, EF>>::one(), <UF<F, EF>>::zero()),
                (<UF<F, EF>>::one(), <UF<F, EF>>::zero()),
                (UF::BaseField(-F::one()), <UF<F, EF>>::one()),
            ],
            random,
        );
        sum_added
    }

    /// Return the random coefficients of each product in the polynomial to be proved in the sumcheck protocol.
    /// These random coefficients are used to randomize newly added sub-sumcheck protocols.
    #[inline]
    pub fn random_coin(trans: &mut Transcript<F>, info: &AdditionInZqInstanceInfo<F>) -> Vec<EF> {
        let mut random = <BitDecomposition<F, EF>>::random_coin(trans, &info.decomposed_bits_info);
        let random_extra =
            trans.get_ext_field_challenge::<EF>(b"combine a sumcheck protocol in addition in zq");
        random.push(random_extra);
        random
    }

    /// Prove addition in Zq given a, b, c, k, and the decomposed bits for a, b, and c.
    /// This function does the same thing as `prove`, but it uses a `Fiat-Shamir RNG` as the transcript/to generate the
    /// verifier challenges.
    pub fn prove(
        trans: &mut Transcript<F>,
        addition_instance: &AdditionInZqInstance<F>,
        u: &[EF],
    ) -> AdditionInZqProof<F, EF> {
        // 1. rangecheck
        let rangecheck_msg = BitDecomposition::prove(trans, &addition_instance.abc_bits, u);

        let dim = u.len();
        assert_eq!(dim, addition_instance.num_vars);
        let mut poly = <ListOfProductsOfPolynomials<F, EF>>::new(dim);

        // Convert the MLE over Field in the original instance to a new instance containing the corresponding MLE over Extension Field
        let instance_ext = <AdditionInZqInstanceExt<F, EF>>::from_base(addition_instance);

        // 2. execute sumcheck for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
        poly.add_product_with_linear_op(
            [
                Rc::new(gen_identity_evaluations(u)),
                Rc::clone(&instance_ext.k),
                Rc::clone(&instance_ext.k),
            ],
            &[
                (<UF<F, EF>>::one(), <UF<F, EF>>::zero()),
                (<UF<F, EF>>::one(), <UF<F, EF>>::zero()),
                (UF::BaseField(-F::one()), <UF<F, EF>>::one()),
            ],
            EF::one(),
        );
        let sumcheck_proof =
            MLSumcheck::prove(trans, &poly).expect("sumcheck for addition in Zq failed");

        AdditionInZqProof {
            rangecheck_msg,
            sumcheck_msg: sumcheck_proof.0,
        }
    }

    /// Verify addition in Zq given the proof and the verification key for bit decomposistion
    pub fn verify(
        trans: &mut Transcript<F>,
        proof: &AdditionInZqProof<F, EF>,
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> AdditionInZqSubclaim<F, EF> {
        let rangecheck_subclaim =
            BitDecomposition::verify(trans, &proof.rangecheck_msg, decomposed_bits_info);

        // execute sumcheck for \sum_{x} eq(u, x) * k(x) * (1-k(x)) = 0, i.e. k(x)\in\{0,1\}^l
        let poly_info = PolynomialInfo {
            max_multiplicands: 3,
            num_variables: decomposed_bits_info.num_vars,
        };

        let subclaim = MLSumcheck::verify(trans, &poly_info, EF::zero(), &proof.sumcheck_msg)
            .expect("sumcheck protocol in addition in Zq failed");
        AdditionInZqSubclaim {
            rangecheck_subclaim,
            sumcheck_point: subclaim.point,
            sumcheck_expected_evaluations: subclaim.expected_evaluations,
        }
    }
}
