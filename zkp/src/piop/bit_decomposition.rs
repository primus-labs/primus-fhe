//! PIOP for Bit Decomposition (which could also be used for Range Check)
//! Define the structures required in SNARKs for Bit Decomposition
//! The prover wants to convince that the decomposition of an element into some bits on a power-of-two base.
//! * base (denoted by B): the power-of-two base used in bit decomposition
//! * base_len: the length of base, i.e. log_2(base)
//! * bits_len (denoted by l): the length of decomposed bits
//!
//! Given M instances of bit decomposition to be proved, d and each bit of d, i.e. (d_0, ..., d_l),
//! the main idea of this IOP is to prove:
//! For x \in \{0, 1\}^l
//! 1. d(x) = \sum_{i=0}^{log M - 1} B^i d_i(x) => can be reduced to the evaluation of a random point
//! 2. For every i \in \[l\]: \prod_{k = 0}^B (d_i(x) - k) = 0 =>
//!     a) each of which can be reduced to prove the following sum
//!        $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
//!        where u is the common random challenge from the verifier, used to instantiate every sum,
//!     b) and then, it can be proved with the sumcheck protocol where the maximum variable-degree is B + 1.
//!
//! The second part consists of l sumcheck protocols which can be combined into one giant sumcheck via random linear combination,
//! then the resulting purported sum is:
//! $\sum_{x \in \{0, 1\}^\log M} \sum_{i = 0}^{l-1} r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
//! where r_i (for i = 0..l) are sampled from the verifier.
use algebra::utils::Transcript;
use algebra::{
    AbstractExtensionField, DecomposableField, DenseMultilinearExtension,
    DenseMultilinearExtensionBase, Field, UF,
};
use serde::Serialize;
use std::marker::PhantomData;
use std::rc::Rc;

use crate::sumcheck::prover::ProverMsg;

use crate::sumcheck::MLSumcheck;
use crate::utils::{eval_identity_function, gen_identity_evaluations};
use algebra::{ListOfProductsOfPolynomials, PolynomialInfo};

/// SNARKs for bit decomposition
pub struct BitDecomposition<F: Field, EF: AbstractExtensionField<F>> {
    _marker: PhantomData<F>,
    _stone: PhantomData<EF>,
}

/// proof generated by prover
pub struct BitDecompositionProof<F: Field, EF: AbstractExtensionField<F>> {
    pub(crate) sumcheck_msg: Vec<ProverMsg<F, EF>>,
}

/// subclaim returned to verifier
pub struct BitDecompositionSubClaim<F: Field, EF: AbstractExtensionField<F>> {
    /// r
    pub randomness: Vec<EF>,
    /// reduced point from the sumcheck protocol
    pub point: Vec<EF>,
    /// expected value returned in sumcheck
    pub expected_evaluation: EF,
    /// marker for F
    _marker: PhantomData<F>,
}

/// Stores the parameters used for bit decomposation and every instance of decomposed bits,
/// and the batched polynomial used for the sumcheck protocol.
///
/// It is required to decompose over a power-of-2 base.
/// The resulting decomposed bits are used as the prover key.
pub struct DecomposedBits<F: Field> {
    /// base
    pub base: F,
    /// the length of base, i.e. log_2(base)
    pub base_len: u32,
    /// the length of decomposed bits
    pub bits_len: u32,
    /// number of variables of every polynomial
    pub num_vars: usize,
    /// batched plain deomposed bits, each of which corresponds to one bit decomposisiton instance
    pub instances: Vec<Vec<Rc<DenseMultilinearExtensionBase<F>>>>,
}

/// Store the corresponding MLE of DecomposedBits where the evaluations are over the extension field.
pub struct DecomposedBitsExt<F: Field, EF: AbstractExtensionField<F>> {
    /// batched plain deomposed bits, each of which corresponds to one bit decomposisiton instance
    pub instances: Vec<Vec<Rc<DenseMultilinearExtension<F, EF>>>>,
}

impl<F: Field, EF: AbstractExtensionField<F>> DecomposedBitsExt<F, EF> {
    /// Construct an instance over the extension field from the original instance defined over the basic field
    pub fn from_base(input_base: &DecomposedBits<F>) -> Self {
        DecomposedBitsExt {
            instances: input_base
                .instances
                .iter()
                .map(|instance| {
                    instance
                        .iter()
                        .map(|bit| Rc::new(DenseMultilinearExtension::from_base(bit.as_ref())))
                        .collect::<Vec<_>>()
                })
                .collect::<Vec<_>>(),
        }
    }

    #[inline]
    /// Batch all the sumcheck protocol, each corresponding to range-check one single bit.
    /// * randomness: randomness used to linearly combine bits_len * num_instances sumcheck protocols
    /// * u is the common random challenge from the verifier, used to instantiate every sum.
    pub fn randomized_sumcheck(
        &self,
        instance_base: &DecomposedBits<F>,
        randomness: &[EF],
        u: &[EF],
    ) -> ListOfProductsOfPolynomials<F, EF> {
        assert_eq!(
            randomness.len(),
            self.instances.len() * instance_base.bits_len as usize
        );
        assert_eq!(u.len(), instance_base.num_vars);

        let mut poly = <ListOfProductsOfPolynomials<F, EF>>::new(instance_base.num_vars);
        let identity_func_at_u = Rc::new(gen_identity_evaluations(u));
        let base = 1 << instance_base.base_len;

        let mut r_iter = randomness.iter();

        for instance in &self.instances {
            // For every bit, the reduced sum is $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
            // and the added product is r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] with the corresponding randomness
            for bit in instance {
                let mut product: Vec<_> = Vec::with_capacity(base + 1);
                let mut op_coefficient = Vec::with_capacity(base + 1);
                product.push(Rc::clone(&identity_func_at_u));
                op_coefficient.push((UF::one(), UF::zero()));

                let mut minus_k = F::zero();
                for _ in 0..base {
                    product.push(Rc::clone(bit));
                    op_coefficient.push((UF::one(), UF::BaseField(minus_k)));
                    minus_k -= F::one();
                }
                poly.add_product_with_linear_op(product, &op_coefficient, *r_iter.next().unwrap());
            }
        }
        poly
    }
}

/// Stores the parameters used for bit decomposation.
///
/// * It is required to decompose over a power-of-2 base.
///
/// These parameters are used as the verifier key.
#[derive(Clone, Serialize)]
pub struct DecomposedBitsInfo<F: Field> {
    /// base
    pub base: F,
    /// the length of base, i.e. log_2(base)
    pub base_len: u32,
    /// the length of decomposed bits (denoted by l)
    pub bits_len: u32,
    /// number of variables of every polynomial
    pub num_vars: usize,
    /// number of instances
    pub num_instances: usize,
}

impl<F: Field> DecomposedBits<F> {
    #[inline]
    /// Extract the information of decomposed bits for verification
    pub fn info(&self) -> DecomposedBitsInfo<F> {
        DecomposedBitsInfo {
            base: self.base,
            base_len: self.base_len,
            bits_len: self.bits_len,
            num_vars: self.num_vars,
            num_instances: self.instances.len(),
        }
    }

    /// Initiate the polynomial used for sumcheck protocol
    #[inline]
    pub fn new(base: F, base_len: u32, bits_len: u32, num_vars: usize) -> Self {
        DecomposedBits {
            base,
            base_len,
            bits_len,
            num_vars,
            instances: Vec::new(),
        }
    }

    /// Initiate the polynomial from the given info used for sumcheck protocol
    #[inline]
    pub fn from_info(info: &DecomposedBitsInfo<F>) -> Self {
        DecomposedBits {
            base: info.base,
            base_len: info.base_len,
            bits_len: info.bits_len,
            num_vars: info.num_vars,
            instances: Vec::with_capacity(info.num_instances),
        }
    }

    #[inline]
    /// Add one bit decomposition instance, meaning to add l sumcheck protocols.
    /// * decomposed_bits: store each bit
    pub fn add_decomposed_bits_instance(
        &mut self,
        decomposed_bits: &[Rc<DenseMultilinearExtensionBase<F>>],
    ) {
        assert_eq!(decomposed_bits.len(), self.bits_len as usize);
        for bit in decomposed_bits {
            assert_eq!(bit.num_vars, self.num_vars);
        }
        self.instances.push(decomposed_bits.to_vec());
    }

    #[inline]
    /// Generate the oracle to be committed that is composed of all the small oracles used in IOP.
    /// The arrangement of this oracle should be consistent to its usage in verifying the subclaim.
    /// When verifying the subclaim:
    ///
    /// * Prover
    /// 1. first computes all the requested evaluations defined over these small oracles.
    /// 2. then sends these opened evaluations to the verifier
    /// 3. use random linear combination to reduce these evaluations to be proved into a single random point over the committed large oracle.
    /// * Verifier
    /// 1. verifier first checks the relation among these evaluations the way as in the old interface `verify_subclaim`
    /// 2. verifier then checks the random linear combination between these evaluations of small oracles and the final single evaluation over the committed large oracle.
    /// 3. verifier finally checks the evaluation of the committed large oracle (outside the implementation of IOP)
    pub fn gen_oracle(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
    ) -> DenseMultilinearExtensionBase<F> {
        assert_eq!(d_val.len(), self.instances.len());
        let num_oracles = self.instances.len() * (self.bits_len as usize + 1);
        let num_vars_added = num_oracles.next_power_of_two().ilog2() as usize;
        let num_vars = self.num_vars + num_vars_added;
        let num_zeros_padded = ((1 << num_vars_added) - num_oracles) * (1 << self.num_vars);
    
        let evals = self
            .instances
            .iter()
            .flatten()
            .flat_map(|bit| bit.iter())
            .chain(
                // combined with the d_val
                d_val.iter()
                    .flat_map(|d| d.iter())
            )
            .map(|x| *x)
            .chain(
                // padded with zeros
                (0..num_zeros_padded).map(|_| F::zero())
            )
            .collect::<Vec<F>>();

        <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(num_vars, evals)
    }
}

impl<F: DecomposableField> DecomposedBits<F> {
    /// Use the base defined in this instance to perform decomposition over the input value.
    /// Then add the result into this instance, meaning to add l sumcheck protocols.
    /// * decomposed_bits: store each bit
    #[inline]
    pub fn add_value_instance(&mut self, value: &DenseMultilinearExtensionBase<F>) {
        assert_eq!(self.num_vars, value.num_vars);
        self.instances
            .push(value.get_decomposed_mles(self.base_len, self.bits_len));
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> BitDecompositionSubClaim<F, EF> {
    /// prover needs to compute the evaluations given the MLEs
    pub fn prove_subclaim(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
        d_bits: &[&Vec<Rc<DenseMultilinearExtensionBase<F>>>],
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> Vec<EF> {
        assert_eq!(d_val.len(), decomposed_bits_info.num_instances);
        assert_eq!(d_bits.len(), decomposed_bits_info.num_instances);

        d_bits
            .iter()
            .flat_map(|bits| bits.iter())
            .chain(d_val.iter())
            .map(|mle| mle.evaluate_ext(&self.point))
            .collect::<Vec<EF>>()
    }

    /// verifier first checks the relation of these given evals
    ///
    /// # Argument
    ///
    /// * `evals`: This vector consists of evaluations of all relevant MLEs. You can find the specific arrangement in `prove_subclaim`.
    pub fn verify_subclaim_pcs(
        &self,
        evals: &[EF],
        u: &[EF],
        info: &DecomposedBitsInfo<F>,
        oracle_eval: EF,
        trans: &mut Transcript<F>,
    ) -> bool {
        assert_eq!(
            evals.len(),
            info.num_instances + info.num_instances * info.bits_len as usize
        );
        let d_val_at_point = &evals[evals.len() - info.num_instances..];
        let d_bits_at_point = &evals[..evals.len() - info.num_instances];

        // base_pow = [1, B, ..., B^{l-1}]
        let mut base_pow = vec![F::one(); info.bits_len as usize];
        base_pow.iter_mut().fold(F::one(), |acc, pow| {
            *pow *= acc;
            acc * info.base
        });

        // check 1: d[point] = \sum_{i=0}^len B^i \cdot d_i[point] for every instance
        if !d_bits_at_point
            .chunks_exact(info.bits_len as usize)
            .zip(d_val_at_point)
            .all(|(bits, val)| {
                *val == bits
                    .iter()
                    .zip(base_pow.iter())
                    .fold(EF::zero(), |acc, (bit, pow)| acc + *bit * *pow)
            })
        {
            return false;
        }

        // check 2: expected value returned in sumcheck
        // each instance contributes value: eq(u, x) \cdot \sum_{i = 0}^{l-1} r_i \cdot [\prod_{k=0}^B (d_i(x) - k)] =? expected_evaluation
        let mut evaluation = EF::zero();
        let mut r = self.randomness.iter();
        d_bits_at_point
            .chunks_exact(info.bits_len as usize)
            .for_each(|bits| {
                bits.iter().for_each(|bit| {
                    let mut prod = *r.next().unwrap();
                    let mut minus_k = F::zero();
                    for _ in 0..(1 << info.base_len) {
                        prod *= *bit + minus_k;
                        minus_k -= F::one();
                    }
                    evaluation += prod;
                })
            });
        
        if !(self.expected_evaluation == evaluation * eval_identity_function(u, &self.point)) {
            return  false;
        }

        // Verify the relationship between the evaluations of these small oracles and the requested evaluation of the committed oracle
        let num_oracles = info.num_instances * (info.bits_len as usize + 1);
        let num_vars_added = num_oracles.next_power_of_two().ilog2() as usize;
        let randomness_oracles = trans.get_vec_ext_field_challenge::<EF>(b"random linear combination for evaluations of oracles", num_vars_added);
        let eq_at_r = gen_identity_evaluations(&randomness_oracles);
        let randomized_eval = evals.iter().zip(eq_at_r.iter())
            .fold(EF::zero(), |acc, (eval, coeff)| {
                acc + *eval * *coeff
            });
        randomized_eval == oracle_eval
    }

    /// verify the subclaim given the MLEs
    ///
    /// # Argument
    ///   
    /// * `d_val` stores each value to be decomposed
    /// * `d_bits` stores the decomposed bits for each value in d_val
    /// * `u` is the common random challenge from the verifier, used to instantiate every sum.
    pub fn verify_subclaim(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
        d_bits: &[&Vec<Rc<DenseMultilinearExtensionBase<F>>>],
        u: &[EF],
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> bool {
        assert_eq!(d_val.len(), decomposed_bits_info.num_instances);
        assert_eq!(d_bits.len(), decomposed_bits_info.num_instances);
        assert_eq!(u.len(), decomposed_bits_info.num_vars);

        let d_val_at_point: Vec<_> = d_val
            .iter()
            .map(|val| val.evaluate_ext(&self.point))
            .collect();
        let d_bits_at_point: Vec<Vec<_>> = d_bits
            .iter()
            .map(|bits| {
                bits.iter()
                    .map(|bit| bit.evaluate_ext(&self.point))
                    .collect()
            })
            .collect();

        // base_pow = [1, B, ..., B^{l-1}]
        let mut base_pow = vec![F::one(); decomposed_bits_info.bits_len as usize];
        base_pow.iter_mut().fold(F::one(), |acc, pow| {
            *pow *= acc;
            acc * decomposed_bits_info.base
        });

        // check 1: d[point] = \sum_{i=0}^len B^i \cdot d_i[point] for every instance
        if !d_val_at_point
            .iter()
            .zip(d_bits_at_point.iter())
            .all(|(val, bits)| {
                *val == bits
                    .iter()
                    .zip(base_pow.iter())
                    .fold(EF::zero(), |acc, (bit, pow)| acc + *bit * *pow)
            })
        {
            return false;
        }

        // check 2: expected value returned in sumcheck
        // each instance contributes value: eq(u, x) \cdot \sum_{i = 0}^{l-1} r_i \cdot [\prod_{k=0}^B (d_i(x) - k)] =? expected_evaluation
        let mut evaluation = EF::zero();
        let mut r = self.randomness.iter();
        d_bits_at_point.iter().for_each(|bits| {
            bits.iter().for_each(|bit| {
                let mut prod = *r.next().unwrap();
                let mut minus_k = F::zero();
                for _ in 0..(1 << decomposed_bits_info.base_len) {
                    prod *= *bit + minus_k;
                    minus_k -= F::one();
                }
                evaluation += prod;
            })
        });
        self.expected_evaluation == evaluation * eval_identity_function(u, &self.point)
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> BitDecomposition<F, EF> {
    /// Prove bit decomposition given the decomposed bits as prover key.
    pub fn prove(
        trans: &mut Transcript<F>,
        decomposed_bits_base: &DecomposedBits<F>,
        u: &[EF],
    ) -> BitDecompositionProof<F, EF> {
        let num_bits =
            decomposed_bits_base.instances.len() * decomposed_bits_base.bits_len as usize;
        trans.append_message(b"decomposed bits", &decomposed_bits_base.info());

        // batch `len_bits` sumcheck protocols into one with random linear combination
        let randomness = trans
            .get_vec_ext_field_challenge(b"randomness to combine sumcheck protocols", num_bits);

        // Convert to a new instance defined over extension field
        let decomposed_bits = <DecomposedBitsExt<F, EF>>::from_base(decomposed_bits_base);
        let poly = decomposed_bits.randomized_sumcheck(decomposed_bits_base, &randomness, u);

        trans.append_message(b"sumcheck protocol", &poly.info());
        BitDecompositionProof {
            sumcheck_msg: MLSumcheck::prove(trans, &poly)
                .expect("bit decomposition failed")
                .0,
        }
    }

    /// Verify bit decomposition given the basic information of decomposed bits as verifier key.
    pub fn verify(
        trans: &mut Transcript<F>,
        proof: &BitDecompositionProof<F, EF>,
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> BitDecompositionSubClaim<F, EF> {
        let num_bits = decomposed_bits_info.num_instances * decomposed_bits_info.bits_len as usize;
        trans.append_message(b"decomposed bits", decomposed_bits_info);
        // batch `len_bits` sumcheck protocols into one with random linear combination
        let randomness = trans
            .get_vec_ext_field_challenge(b"randomness to combine sumcheck protocols", num_bits);
        let poly_info = PolynomialInfo {
            max_multiplicands: 1 + (1 << decomposed_bits_info.base_len),
            num_variables: decomposed_bits_info.num_vars,
        };
        trans.append_message(b"sumcheck protocol", &poly_info);
        let subclaim = MLSumcheck::verify(trans, &poly_info, EF::zero(), &proof.sumcheck_msg)
            .expect("bit decomposition verification failed");
        BitDecompositionSubClaim {
            randomness,
            point: subclaim.point,
            expected_evaluation: subclaim.expected_evaluations,
            _marker: PhantomData,
        }
    }
}
