//! PIOP for Bit Decomposition (which could also be used for Range Check)
//! Define the structures required in SNARKs for Bit Decomposition
//! The prover wants to convince that the decomposition of an element into some bits on a power-of-two base.
//! * base (denoted by B): the power-of-two base used in bit decomposition
//! * base_len: the length of base, i.e. log_2(base)
//! * bits_len (denoted by l): the length of decomposed bits
//!
//! Given M instances of bit decomposition to be proved, d and each bit of d, i.e. (d_0, ..., d_l),
//! the main idea of this IOP is to prove:
//! For x \in \{0, 1\}^l
//! 1. d(x) = \sum_{i=0}^{log M - 1} B^i d_i(x) => can be reduced to the evaluation of a random point
//! 2. For every i \in \[l\]: \prod_{k = 0}^B (d_i(x) - k) = 0 =>
//!     a) each of which can be reduced to prove the following sum
//!        $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
//!        where u is the common random challenge from the verifier, used to instantiate every sum,
//!     b) and then, it can be proved with the sumcheck protocol where the maximum variable-degree is B + 1.
//!
//! The second part consists of l sumcheck protocols which can be combined into one giant sumcheck via random linear combination,
//! then the resulting purported sum is:
//! $\sum_{x \in \{0, 1\}^\log M} \sum_{i = 0}^{l-1} r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
//! where r_i (for i = 0..l) are sampled from the verifier.
use algebra::utils::Transcript;
use algebra::{
    AbstractExtensionField, DecomposableField, DenseMultilinearExtension,
    DenseMultilinearExtensionBase, Field, UF,
};
use core::fmt;
use serde::Serialize;
use std::marker::PhantomData;
use std::rc::Rc;

use crate::sumcheck::prover::ProverMsg;

use crate::sumcheck::verifier::SubClaim;
use crate::sumcheck::MLSumcheck;
use crate::utils::{eval_identity_function, gen_identity_evaluations};
use algebra::{ListOfProductsOfPolynomials, PolynomialInfo};

/// SNARKs for bit decomposition
pub struct BitDecomposition<F: Field, EF: AbstractExtensionField<F>> {
    _marker: PhantomData<F>,
    _stone: PhantomData<EF>,
}

/// proof generated by prover
#[derive(Serialize)]
pub struct BitDecompositionProof<F: Field, EF: AbstractExtensionField<F>> {
    pub(crate) sumcheck_msg: Vec<ProverMsg<F, EF>>,
}

/// subclaim returned to verifier
pub struct BitDecompositionSubClaim<F: Field, EF: AbstractExtensionField<F>> {
    /// r
    pub randomness: Vec<EF>,
    /// reduced point from the sumcheck protocol
    pub point: Vec<EF>,
    /// expected value returned in sumcheck
    pub expected_evaluation: EF,
    /// marker for F
    _marker: PhantomData<F>,
}

/// Stores the parameters used for bit decomposation and every instance of decomposed bits,
/// and the batched polynomial used for the sumcheck protocol.
///
/// It is required to decompose over a power-of-2 base.
/// The resulting decomposed bits are used as the prover key.
pub struct DecomposedBits<F: Field> {
    /// base
    pub base: F,
    /// the length of base, i.e. log_2(base)
    pub base_len: u32,
    /// the length of decomposed bits
    pub bits_len: u32,
    /// number of variables of every polynomial
    pub num_vars: usize,
    // TODO: add d_vals in this structure
    /// batched plain deomposed bits, each of which corresponds to one bit decomposisiton instance
    pub d_bits: Vec<Vec<Rc<DenseMultilinearExtensionBase<F>>>>,
}

/// Store the corresponding MLE of DecomposedBits where the evaluations are over the extension field.
pub struct DecomposedBitsExt<F: Field, EF: AbstractExtensionField<F>> {
    /// batched plain deomposed bits, each of which corresponds to one bit decomposisiton instance
    pub d_bits: Vec<Vec<Rc<DenseMultilinearExtension<F, EF>>>>,
}

impl<F: Field, EF: AbstractExtensionField<F>> DecomposedBitsExt<F, EF> {
    /// Construct an instance over the extension field from the original instance defined over the basic field
    pub fn from_base(input_base: &DecomposedBits<F>) -> Self {
        DecomposedBitsExt {
            d_bits: input_base
                .d_bits
                .iter()
                .map(|instance| {
                    instance
                        .iter()
                        .map(|bit| Rc::new(DenseMultilinearExtension::from_base(bit.as_ref())))
                        .collect::<Vec<_>>()
                })
                .collect::<Vec<_>>(),
        }
    }

    #[inline]
    /// Batch all the sumcheck protocol, each corresponding to range-check one single bit.
    /// * randomness: randomness used to linearly combine bits_len * num_instances sumcheck protocols
    /// * u is the common random challenge from the verifier, used to instantiate every sum.
    pub fn poly_randomized_sumcheck(
        &self,
        poly: &mut ListOfProductsOfPolynomials<F, EF>,
        instance_base: &DecomposedBits<F>,
        randomness: &[EF],
        u: &[EF],
    ) {
        assert_eq!(
            randomness.len(),
            self.d_bits.len() * instance_base.bits_len as usize
        );
        assert_eq!(u.len(), instance_base.num_vars);

        let identity_func_at_u = Rc::new(gen_identity_evaluations(u));
        let base = 1 << instance_base.base_len;

        let mut r_iter = randomness.iter();

        for instance in &self.d_bits {
            // For every bit, the reduced sum is $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
            // and the added product is r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] with the corresponding randomness
            for bit in instance {
                let mut product: Vec<_> = Vec::with_capacity(base + 1);
                let mut op_coefficient = Vec::with_capacity(base + 1);
                product.push(Rc::clone(&identity_func_at_u));
                op_coefficient.push((UF::one(), UF::zero()));

                let mut minus_k = F::zero();
                for _ in 0..base {
                    product.push(Rc::clone(bit));
                    op_coefficient.push((UF::one(), UF::BaseField(minus_k)));
                    minus_k -= F::one();
                }
                poly.add_product_with_linear_op(product, &op_coefficient, *r_iter.next().unwrap());
            }
        }
    }

    // TODO TO DELETE
    #[inline]
    /// Batch all the sumcheck protocol, each corresponding to range-check one single bit.
    /// * randomness: randomness used to linearly combine bits_len * num_instances sumcheck protocols
    /// * u is the common random challenge from the verifier, used to instantiate every sum.
    pub fn randomized_sumcheck(
        &self,
        instance_base: &DecomposedBits<F>,
        randomness: &[EF],
        u: &[EF],
    ) -> ListOfProductsOfPolynomials<F, EF> {
        assert_eq!(
            randomness.len(),
            self.d_bits.len() * instance_base.bits_len as usize
        );
        assert_eq!(u.len(), instance_base.num_vars);

        let mut poly = <ListOfProductsOfPolynomials<F, EF>>::new(instance_base.num_vars);
        let identity_func_at_u = Rc::new(gen_identity_evaluations(u));
        let base = 1 << instance_base.base_len;

        let mut r_iter = randomness.iter();

        for instance in &self.d_bits {
            // For every bit, the reduced sum is $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
            // and the added product is r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] with the corresponding randomness
            for bit in instance {
                let mut product: Vec<_> = Vec::with_capacity(base + 1);
                let mut op_coefficient = Vec::with_capacity(base + 1);
                product.push(Rc::clone(&identity_func_at_u));
                op_coefficient.push((UF::one(), UF::zero()));

                let mut minus_k = F::zero();
                for _ in 0..base {
                    product.push(Rc::clone(bit));
                    op_coefficient.push((UF::one(), UF::BaseField(minus_k)));
                    minus_k -= F::one();
                }
                poly.add_product_with_linear_op(product, &op_coefficient, *r_iter.next().unwrap());
            }
        }
        poly
    }
}

/// Stores the parameters used for bit decomposation.
///
/// * It is required to decompose over a power-of-2 base.
///
/// These parameters are used as the verifier key.
#[derive(Clone, Serialize)]
pub struct DecomposedBitsInfo<F: Field> {
    /// base
    pub base: F,
    /// the length of base, i.e. log_2(base)
    pub base_len: u32,
    /// the length of decomposed bits (denoted by l)
    pub bits_len: u32,
    /// number of variables of every polynomial
    pub num_vars: usize,
    /// number of instances
    pub num_instances: usize,
}

impl<F: Field> fmt::Display for DecomposedBitsInfo<F> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} instances of Decomposed Bits: #vars = {}, base = 2^{}, #bits = {}",
            self.num_instances, self.num_vars, self.base_len, self.bits_len
        )
    }
}

impl<F: Field> DecomposedBitsInfo<F> {
    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // number of value oracle + number of decomposed bits oracle
        self.num_instances * (self.bits_len as usize + 1)
    }

    /// Return the number of random coefficient sampled to randomize sumcheck protocols
    #[inline]
    pub fn num_coins(&self) -> usize {
        self.num_instances * self.bits_len as usize
    }

    /// Compute the evaluation over the random point of the polynomial proved in the sumcheck protocol
    #[inline]
    pub fn compute_subclaim_eval<EF: AbstractExtensionField<F>>(
        &self,
        evals: &[EF],
        u: &[EF],
        coins: &[EF],
        subclaim: &SubClaim<F, EF>,
    ) -> EF {
        let d_bits_at_point = &evals[self.num_instances..];

        // expected value returned in sumcheck
        // each instance contributes value: eq(u, x) \cdot \sum_{i = 0}^{l-1} r_i \cdot [\prod_{k=0}^B (d_i(x) - k)] =? expected_evaluation
        let mut evaluation = EF::zero();
        let mut r = coins.iter();
        d_bits_at_point
            .chunks_exact(self.bits_len as usize)
            .for_each(|bits| {
                bits.iter().for_each(|bit| {
                    let mut prod = *r.next().unwrap();
                    let mut minus_k = F::zero();
                    for _ in 0..(1 << self.base_len) {
                        prod *= *bit + minus_k;
                        minus_k -= F::one();
                    }
                    evaluation += prod;
                })
            });

        evaluation * eval_identity_function(u, &subclaim.point)
    }

    /// Verify the subclaim using the evalustions sent by the prover instead of the whole MLEs.
    ///
    /// # Argument
    ///
    /// * `evals`: vector consisting of all the evaluations of relevant MLEs. The arrangement is consistent to the vector returned in `compute_evals`.
    /// * `random_u`: random point used to instantiate all the sub-sumcheck protocols
    /// * `coins`: random elements used to randomize sub-sumcheck protocols with linear combination
    /// * `subclaim`: subclaim returned from the randomized sumcheck protocol
    #[inline]
    pub fn verify_subclaim<EF: AbstractExtensionField<F>>(
        &self,
        evals: &[EF],
        random_u: &[EF],
        coins: &[EF],
        subclaim: &SubClaim<F, EF>,
    ) -> bool {
        assert_eq!(evals.len(), self.num_oracles());
        // arrangement: all values||all decomposed bits
        let d_val_at_point = &evals[..self.num_instances];
        let d_bits_at_point = &evals[self.num_instances..];

        // base_pow = [1, B, ..., B^{l-1}]
        let mut base_pow = vec![F::one(); self.bits_len as usize];
        base_pow.iter_mut().fold(F::one(), |acc, pow| {
            *pow *= acc;
            acc * self.base
        });

        // check 1: d[point] = \sum_{i=0}^len B^i \cdot d_i[point] for every instance
        if !d_bits_at_point
            .chunks_exact(self.bits_len as usize)
            .zip(d_val_at_point)
            .all(|(bits, val)| {
                *val == bits
                    .iter()
                    .zip(base_pow.iter())
                    .fold(EF::zero(), |acc, (bit, pow)| acc + *bit * *pow)
            })
        {
            return false;
        }

        // check 2: expected value returned in sumcheck
        // each instance contributes value: eq(u, x) \cdot \sum_{i = 0}^{l-1} r_i \cdot [\prod_{k=0}^B (d_i(x) - k)] =? expected_evaluation
        subclaim.expected_evaluations
            == self.compute_subclaim_eval(evals, random_u, coins, subclaim)
    }
}

impl<F: Field> DecomposedBits<F> {
    #[inline]
    /// Extract the information of decomposed bits for verification
    pub fn info(&self) -> DecomposedBitsInfo<F> {
        DecomposedBitsInfo {
            base: self.base,
            base_len: self.base_len,
            bits_len: self.bits_len,
            num_vars: self.num_vars,
            num_instances: self.d_bits.len(),
        }
    }

    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        // number of value oracle + number of decomposed bits oracle
        self.d_bits.len() * (self.bits_len as usize + 1)
    }

    /// Initiate the polynomial used for sumcheck protocol
    #[inline]
    pub fn new(base: F, base_len: u32, bits_len: u32, num_vars: usize) -> Self {
        DecomposedBits {
            base,
            base_len,
            bits_len,
            num_vars,
            d_bits: Vec::new(),
        }
    }

    /// Initiate the polynomial from the given info used for sumcheck protocol
    #[inline]
    pub fn from_info(info: &DecomposedBitsInfo<F>) -> Self {
        DecomposedBits {
            base: info.base,
            base_len: info.base_len,
            bits_len: info.bits_len,
            num_vars: info.num_vars,
            d_bits: Vec::with_capacity(info.num_instances),
        }
    }

    #[inline]
    /// Add one bit decomposition instance, meaning to add l sumcheck protocols.
    /// * decomposed_bits: store each bit
    pub fn add_decomposed_bits_instance(
        &mut self,
        decomposed_bits: &[Rc<DenseMultilinearExtensionBase<F>>],
    ) {
        assert_eq!(decomposed_bits.len(), self.bits_len as usize);
        for bit in decomposed_bits {
            assert_eq!(bit.num_vars, self.num_vars);
        }
        self.d_bits.push(decomposed_bits.to_vec());
    }

    /// Pack all the involved small polynomials into a single vector of evaluations without padding zeros.
    pub fn pack_all_mles(&self, d_val: &[Rc<DenseMultilinearExtensionBase<F>>]) -> Vec<F> {
        assert_eq!(d_val.len(), self.d_bits.len());

        // arrangement: all values||all decomposed bits
        d_val
            .iter()
            .flat_map(|d| d.iter())
            // concatenated with decomposed bits
            .chain(self.d_bits.iter().flatten().flat_map(|bit| bit.iter()))
            .copied()
            .collect::<Vec<F>>()
    }

    /// Generate the oracle to be committed that is composed of all the small oracles used in IOP.
    /// The evaluations of this oracle is generated by the evaluations of all mles and the padded zeros.
    /// The arrangement of this oracle should be consistent to its usage in verifying the subclaim.
    #[inline]
    pub fn generate_oracle(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
    ) -> DenseMultilinearExtensionBase<F> {
        assert_eq!(d_val.len(), self.d_bits.len());
        let num_oracles = self.num_oracles();
        let num_vars_added = num_oracles.next_power_of_two().ilog2() as usize;
        let num_vars = self.num_vars + num_vars_added;
        let num_zeros_padded = ((1 << num_vars_added) - num_oracles) * (1 << self.num_vars);

        // arrangement: all values||all decomposed bits||padded zeros
        let mut evals = self.pack_all_mles(d_val);
        evals.append(&mut vec![F::zero(); num_zeros_padded]);
        <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(num_vars, evals)
    }

    /// Prover needs to compute the evaluations of all the smaller MLEs at the random point reduced from sumcheck protocol.
    #[inline]
    pub fn compute_evals<EF: AbstractExtensionField<F>>(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
        point: &[EF],
    ) -> Vec<EF> {
        assert_eq!(d_val.len(), self.d_bits.len());

        // arrangement: all values||all decomposed bits
        d_val
            .iter()
            .chain(self.d_bits.iter().flat_map(|bits| bits.iter()))
            .map(|mle| mle.evaluate_ext(point))
            .collect::<Vec<EF>>()
    }
}

impl<F: DecomposableField> DecomposedBits<F> {
    /// Use the base defined in this instance to perform decomposition over the input value.
    /// Then add the result into this instance, meaning to add l sumcheck protocols.
    /// * decomposed_bits: store each bit
    #[inline]
    pub fn add_value_instance(&mut self, value: &DenseMultilinearExtensionBase<F>) {
        assert_eq!(self.num_vars, value.num_vars);
        self.d_bits
            .push(value.get_decomposed_mles(self.base_len, self.bits_len));
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> BitDecompositionSubClaim<F, EF> {
    /// verify the subclaim given the MLEs
    ///
    /// # Argument
    ///   
    /// * `d_val` stores each value to be decomposed
    /// * `d_bits` stores the decomposed bits for each value in d_val
    /// * `u` is the common random challenge from the verifier, used to instantiate every sum.
    pub fn verify_subclaim(
        &self,
        d_val: &[Rc<DenseMultilinearExtensionBase<F>>],
        d_bits: &[&Vec<Rc<DenseMultilinearExtensionBase<F>>>],
        u: &[EF],
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> bool {
        assert_eq!(d_val.len(), decomposed_bits_info.num_instances);
        assert_eq!(d_bits.len(), decomposed_bits_info.num_instances);
        assert_eq!(u.len(), decomposed_bits_info.num_vars);

        let d_val_at_point: Vec<_> = d_val
            .iter()
            .map(|val| val.evaluate_ext(&self.point))
            .collect();
        let d_bits_at_point: Vec<Vec<_>> = d_bits
            .iter()
            .map(|bits| {
                bits.iter()
                    .map(|bit| bit.evaluate_ext(&self.point))
                    .collect()
            })
            .collect();

        // base_pow = [1, B, ..., B^{l-1}]
        let mut base_pow = vec![F::one(); decomposed_bits_info.bits_len as usize];
        base_pow.iter_mut().fold(F::one(), |acc, pow| {
            *pow *= acc;
            acc * decomposed_bits_info.base
        });

        // check 1: d[point] = \sum_{i=0}^len B^i \cdot d_i[point] for every instance
        if !d_val_at_point
            .iter()
            .zip(d_bits_at_point.iter())
            .all(|(val, bits)| {
                *val == bits
                    .iter()
                    .zip(base_pow.iter())
                    .fold(EF::zero(), |acc, (bit, pow)| acc + *bit * *pow)
            })
        {
            return false;
        }

        // check 2: expected value returned in sumcheck
        // each instance contributes value: eq(u, x) \cdot \sum_{i = 0}^{l-1} r_i \cdot [\prod_{k=0}^B (d_i(x) - k)] =? expected_evaluation
        let mut evaluation = EF::zero();
        let mut r = self.randomness.iter();
        d_bits_at_point.iter().for_each(|bits| {
            bits.iter().for_each(|bit| {
                let mut prod = *r.next().unwrap();
                let mut minus_k = F::zero();
                for _ in 0..(1 << decomposed_bits_info.base_len) {
                    prod *= *bit + minus_k;
                    minus_k -= F::one();
                }
                evaluation += prod;
            })
        });
        self.expected_evaluation == evaluation * eval_identity_function(u, &self.point)
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> BitDecomposition<F, EF> {
    /// Update the polynomial to be proved in the sumcheck protocol
    #[inline]
    pub fn random_poly(
        poly: &mut ListOfProductsOfPolynomials<F, EF>,
        trans: &mut Transcript<F>,
        instance: &DecomposedBits<F>,
        random_u: &[EF],
    ) -> EF {
        let num_bits = instance.d_bits.len() * instance.bits_len as usize;

        // batch `len_bits` sumcheck protocols into one with random linear combination
        let randomness = trans
            .get_vec_ext_field_challenge(b"randomness to combine sumcheck protocols", num_bits);

        // Convert to a new instance defined over extension field
        let decomposed_bits = <DecomposedBitsExt<F, EF>>::from_base(instance);

        let identity_func_at_u = Rc::new(gen_identity_evaluations(random_u));
        let base = 1 << instance.base_len;

        let mut r_iter = randomness.iter();

        for bits in &decomposed_bits.d_bits {
            // For every bit, the reduced sum is $\sum_{x \in \{0, 1\}^\log M} eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] = 0$
            // and the added product is r_i \cdot eq(u, x) \cdot [\prod_{k=0}^B (d_i(x) - k)] with the corresponding randomness
            for bit in bits {
                let mut product: Vec<_> = Vec::with_capacity(base + 1);
                let mut op_coefficient = Vec::with_capacity(base + 1);
                product.push(Rc::clone(&identity_func_at_u));
                op_coefficient.push((UF::one(), UF::zero()));

                let mut minus_k = F::zero();
                for _ in 0..base {
                    product.push(Rc::clone(bit));
                    op_coefficient.push((UF::one(), UF::BaseField(minus_k)));
                    minus_k -= F::one();
                }
                poly.add_product_with_linear_op(product, &op_coefficient, *r_iter.next().unwrap());
            }
        }

        EF::zero()
    }

    /// Return the random coefficients of each product in the polynomial to be proved in the sumcheck protocol.
    /// These random coefficients are used to randomize newly added sub-sumcheck protocols.
    #[inline]
    pub fn random_coin(trans: &mut Transcript<F>, info: &DecomposedBitsInfo<F>) -> Vec<EF> {
        let num_bits = info.num_instances * info.bits_len as usize;

        // batch `len_bits` sumcheck protocols into one with random linear combination
        trans.get_vec_ext_field_challenge::<EF>(
            b"randomness to combine sumcheck protocols",
            num_bits,
        )
    }

    /// Prove bit decomposition given the decomposed bits as prover key.
    pub fn prove(
        trans: &mut Transcript<F>,
        decomposed_bits_base: &DecomposedBits<F>,
        u: &[EF],
    ) -> BitDecompositionProof<F, EF> {
        let num_bits = decomposed_bits_base.d_bits.len() * decomposed_bits_base.bits_len as usize;
        trans.append_message(b"decomposed bits", &decomposed_bits_base.info());

        // batch `len_bits` sumcheck protocols into one with random linear combination
        let randomness = trans
            .get_vec_ext_field_challenge(b"randomness to combine sumcheck protocols", num_bits);

        // Convert to a new instance defined over extension field
        let decomposed_bits = <DecomposedBitsExt<F, EF>>::from_base(decomposed_bits_base);
        let poly = decomposed_bits.randomized_sumcheck(decomposed_bits_base, &randomness, u);

        trans.append_message(b"sumcheck protocol", &poly.info());
        BitDecompositionProof {
            sumcheck_msg: MLSumcheck::prove(trans, &poly)
                .expect("bit decomposition failed")
                .0,
        }
    }

    /// Verify bit decomposition given the basic information of decomposed bits as verifier key.
    pub fn verify(
        trans: &mut Transcript<F>,
        proof: &BitDecompositionProof<F, EF>,
        decomposed_bits_info: &DecomposedBitsInfo<F>,
    ) -> BitDecompositionSubClaim<F, EF> {
        let num_bits = decomposed_bits_info.num_instances * decomposed_bits_info.bits_len as usize;
        trans.append_message(b"decomposed bits", decomposed_bits_info);
        // batch `len_bits` sumcheck protocols into one with random linear combination
        let randomness = trans
            .get_vec_ext_field_challenge(b"randomness to combine sumcheck protocols", num_bits);
        let poly_info = PolynomialInfo {
            max_multiplicands: 1 + (1 << decomposed_bits_info.base_len),
            num_variables: decomposed_bits_info.num_vars,
        };
        trans.append_message(b"sumcheck protocol", &poly_info);
        let subclaim = MLSumcheck::verify(trans, &poly_info, EF::zero(), &proof.sumcheck_msg)
            .expect("bit decomposition verification failed");
        BitDecompositionSubClaim {
            randomness,
            point: subclaim.point,
            expected_evaluation: subclaim.expected_evaluations,
            _marker: PhantomData,
        }
    }
}
