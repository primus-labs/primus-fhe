//! Round IOP
//! The round operation is the scaling operation, followed by a floor operation.
//!
//! The round operation takes as input a \in F_Q and outputs b \in Zq such that b = \floor (a * q) / Q.
//! In some senses, this operation maps an interval of F_Q into an element of Zq.
//!
//! The prover is going to prove: for x \in {0, 1}^\logM
//! 1. b(x) \in [q] -> which can be proven with a range check since q is a power-of-two
//! 2. c(x) \in [1, ..., k]
//!     meant to prove c(x) - 1 \in [k]
//!     Let L denote the logarithm of the next power-of-two number that is bigger or equal to k.
//!     Let delta denote 2^L - k
//!     It is necessary to be proven with 2 range checks:
//!         one is to prove c(x) - 1 \in [2^L]
//!         the other is to prove c(x) - 1 + delta \in [2^L]
//! 3. w(x)(1 - w(x)) = 0 where w indicates the option in the following constraint
//! 4. w(x)(a(x)\cdot \lambda_1+b(x)\cdot \lambda_2)+(1-w(x))(a(x)-b(x)\cdot k-c(x))=0
//!     where \lambda_1 and \lambda_2 are chosen by the verifier
use crate::sumcheck::verifier::SubClaim;
use crate::sumcheck::MLSumcheck;
use crate::sumcheck::Proof;
use crate::utils::eval_identity_function;
use crate::utils::gen_identity_evaluations;
use algebra::utils::Transcript;
use algebra::DecomposableField;
use itertools::izip;
use std::marker::PhantomData;
use std::rc::Rc;
use std::vec;

use algebra::{
    DenseMultilinearExtension, Field, FieldUniformSampler, ListOfProductsOfPolynomials,
    MultilinearExtension, PolynomialInfo,
};
use rand_distr::Distribution;

use super::bit_decomposition::{BitDecomposition, BitDecompositionProof, BitDecompositionSubClaim};
use super::{DecomposedBits, DecomposedBitsInfo};

/// Round IOP
pub struct RoundIOP<F: Field>(PhantomData<F>);

/// proof generated by prover
pub struct RoundIOPProof<F: Field> {
    /// range check proof for output b
    pub bit_decomp_proof_output: BitDecompositionProof<F>,
    /// range check proof for offset c - 1
    pub bit_decomp_proof_offset: BitDecompositionProof<F>,
    /// sumcheck msg
    pub sumcheck_msg: Proof<F>,
}
/// Round Instance used as prover keys
pub struct RoundInstance<F: Field> {
    /// number of variables
    pub num_vars: usize,
    /// k = Q - 1 / q where q is the modulus of the output
    pub k: F,
    /// delta = 2^{k_bit_len} - k
    pub delta: F,
    /// input denoted by a \in F_Q
    pub input: Rc<DenseMultilinearExtension<F>>,
    /// output denoted by b \in F_q
    pub output: Rc<DenseMultilinearExtension<F>>,
    /// decomposed bits of ouput used for range check
    pub output_bits: DecomposedBits<F>,

    /// offset denoted by c = a - b * k \in [1, k] such that c - 1 \in [0, k)
    pub offset: Rc<DenseMultilinearExtension<F>>,
    /// offset_aux_bits contains two instances of bit decomposition
    /// decomposed bits of c - 1 \in [0, 2^k_bit_len) used for range check
    /// decomposed bits of c - 1 + delta \in [0, 2^k_bit_len) used for range check
    pub offset_aux_bits: DecomposedBits<F>,

    /// option denoted by w \in {0, 1}
    pub option: Rc<DenseMultilinearExtension<F>>,
}

/// Information about Round Instance used as verifier keys
pub struct RoundInstanceInfo<F: Field> {
    /// k = Q - 1 / q is the modulus of the output
    pub k: F,
    /// delta = 2^k_bits_len - k
    pub delta: F,
    /// decomposition info for outputs
    pub output_bits_info: DecomposedBitsInfo<F>,
    /// decomposition info for offset
    pub offset_bits_info: DecomposedBitsInfo<F>,
}

/// subclaim returned to verifier
pub struct RoundIOPSubclaim<F: Field> {
    /// subclaim returned from the range check for output b \in [q]
    pub bit_decomp_output_subclaim: BitDecompositionSubClaim<F>,
    /// subclaim returned from the range check for offset c - 1 \in [k]
    pub bit_decomp_offset_subclaim: BitDecompositionSubClaim<F>,
    /// subclaim returned from the sumcheck protocol
    pub sumcheck_subclaim: SubClaim<F>,
    /// randomness used in the sumcheck
    pub randomness: (F, F),
}

impl<F: Field> RoundInstance<F> {
    /// Extract the information
    #[inline]
    pub fn info(&self) -> RoundInstanceInfo<F> {
        RoundInstanceInfo {
            k: self.k,
            delta: self.delta,
            output_bits_info: self.output_bits.info(),
            offset_bits_info: self.offset_aux_bits.info(),
        }
    }
}

impl<F: DecomposableField> RoundInstance<F> {
    /// Compute the witness required in proof and construct the instance
    #[inline]
    pub fn new(
        k: F,
        delta: F,
        input: Rc<DenseMultilinearExtension<F>>,
        output: Rc<DenseMultilinearExtension<F>>,
        output_bits_info: &DecomposedBitsInfo<F>,
        offset_bits_info: &DecomposedBitsInfo<F>,
    ) -> Self {
        let num_vars = input.num_vars;
        assert_eq!(num_vars, output.num_vars);
        assert_eq!(num_vars, output_bits_info.num_vars);
        assert_eq!(num_vars, offset_bits_info.num_vars);
        assert_eq!(1, output_bits_info.num_instances);
        assert_eq!(2, offset_bits_info.num_instances);

        let mut output_bits = DecomposedBits::from_info(output_bits_info);
        output_bits.add_value_instance(&output);

        // set w = 1 iff a = 0 & b = 0
        let option = Rc::new(DenseMultilinearExtension::<F>::from_evaluations_vec(
            num_vars,
            input
                .iter()
                .zip(output.iter())
                .map(|(a, b)| match (a.is_zero(), b.is_zero()) {
                    (true, true) => F::one(),
                    _ => F::zero(),
                })
                .collect(),
        ));

        // Note that we must set c \in [1, k] when w = 1 to ensure that c(x) \in [1, k] for all x \in {0,1}^logn
        // if w = 0: c = a - b * k
        // if w = 1: c = 1 defaultly
        let offset = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            num_vars,
            izip!(option.iter(), input.iter(), output.iter())
                .map(|(w, a, b)| match w.is_zero() {
                    true => *a - *b * k,
                    false => F::one(),
                })
                .collect(),
        ));

        let mut offset_aux_bits = DecomposedBits::from_info(offset_bits_info);
        // c - 1
        let c_minus_one = DenseMultilinearExtension::from_evaluations_vec(
            num_vars,
            offset.iter().map(|x| *x - F::one()).collect(),
        );
        // c - 1 + delta
        let c_minus_one_delta = DenseMultilinearExtension::from_evaluations_vec(
            num_vars,
            c_minus_one.iter().map(|x| *x + delta).collect(),
        );
        // decompose c - 1
        offset_aux_bits.add_value_instance(&c_minus_one);
        // decompose c - 1 + delta
        offset_aux_bits.add_value_instance(&c_minus_one_delta);

        Self {
            num_vars,
            k,
            delta,
            input,
            output,
            output_bits,
            offset,
            offset_aux_bits,
            option,
        }
    }
}

impl<F: Field> RoundIOPSubclaim<F> {
    /// verify the subclaim
    #[allow(clippy::too_many_arguments)]
    pub fn verify_subclaim(
        &self,
        u: &[F],
        (lambda_1, lambda_2): (F, F),
        input: &Rc<DenseMultilinearExtension<F>>,
        output: &Rc<DenseMultilinearExtension<F>>,
        output_bits: &Vec<Rc<DenseMultilinearExtension<F>>>,
        offset: &Rc<DenseMultilinearExtension<F>>,
        offset_aux_bits_1: &Vec<Rc<DenseMultilinearExtension<F>>>,
        offset_aux_bits_2: &Vec<Rc<DenseMultilinearExtension<F>>>,
        option: &Rc<DenseMultilinearExtension<F>>,
        info: &RoundInstanceInfo<F>,
    ) -> bool {
        // check 1: check the subclaim returned from the range check for output b \in [q]
        let d_bits = vec![output_bits];
        let d_val = vec![output.clone()];
        if !self.bit_decomp_output_subclaim.verify_subclaim(
            &d_val,
            &d_bits,
            u,
            &info.output_bits_info,
        ) {
            return false;
        }

        // check 2: check the subclaim returned from the range check for offset c - 1 \in [k]
        let d_bits = vec![offset_aux_bits_1, offset_aux_bits_2];
        let c_minus_one = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            offset.num_vars,
            offset.iter().map(|x| *x - F::one()).collect(),
        ));
        let c_minus_one_delta = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            offset.num_vars,
            c_minus_one.iter().map(|x| *x + info.delta).collect(),
        ));
        let d_val = vec![c_minus_one, c_minus_one_delta];
        if !self.bit_decomp_offset_subclaim.verify_subclaim(
            &d_val,
            &d_bits,
            u,
            &info.offset_bits_info,
        ) {
            return false;
        }

        // check 3: check the subclaim returned from the sumcheck protocol
        let (r_1, r_2) = self.randomness;
        let eq_val = eval_identity_function(u, &self.sumcheck_subclaim.point);
        let option_eval = option.evaluate(&self.sumcheck_subclaim.point);
        let input_eval = input.evaluate(&self.sumcheck_subclaim.point);
        let output_eval = output.evaluate(&self.sumcheck_subclaim.point);
        let offset_eval = offset.evaluate(&self.sumcheck_subclaim.point);

        self.sumcheck_subclaim.expected_evaluations
            == r_1 * eq_val * option_eval * (F::one() - option_eval)
                + r_2
                    * eq_val
                    * (option_eval * (input_eval * lambda_1 + output_eval * lambda_2)
                        + (F::one() - option_eval)
                            * (input_eval - output_eval * info.k - offset_eval))
    }
}

impl<F: Field> RoundIOP<F> {
    /// Prove round operation
    pub fn prove(
        instance: &RoundInstance<F>,
        u: &[F],
        (lambda_1, lambda_2): (F, F),
    ) -> RoundIOPProof<F> {
        let mut trans = Transcript::<F>::new();
        Self::prove_as_subprotocol(&mut trans, instance, u, (lambda_1, lambda_2))
    }

    /// Prove round operation
    pub fn prove_as_subprotocol(
        trans: &mut Transcript<F>,
        instance: &RoundInstance<F>,
        u: &[F],
        (lambda_1, lambda_2): (F, F),
    ) -> RoundIOPProof<F> {
        let uniform = <FieldUniformSampler<F>>::new();

        let mut poly = <ListOfProductsOfPolynomials<F>>::new(instance.num_vars);
        let identity_func_at_u = Rc::new(gen_identity_evaluations(u));

        // randomly combine two sumcheck protocols
        let r = trans.get_vec_challenge(b"randomness for sumcheck", 2);
        let r_1 = r[0];
        let r_2 = r[1];

        // sumcheck1 for \sum_{x} eq(u, x) * w(x) * (1-w(x)) = 0, i.e. w(x)\in\{0,1\}^l with random coefficient r_1
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.option),
            ],
            &[
                (F::one(), F::zero()),
                (F::one(), F::zero()),
                (-F::one(), F::one()),
            ],
            r_1,
        );

        // sumcheck2 for \sum_{x} eq(u, x) * [w(x) * (a(x) * \lambda_1 + b(x) * \lambda_2)+(1 - w(x)) * (a(x) - b(x) * k - c(x))]=0
        // with random coefficient r_2 where \lambda_1 and \lambda_2 are chosen by the verifier

        // The following steps add five products composing the function in the above sumcheck protocol
        // product: eq(u, x) * w(x) * (a(x) * \lambda_1)
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.input),
            ],
            &[
                (F::one(), F::zero()),
                (F::one(), F::zero()),
                (lambda_1, F::zero()),
            ],
            r_2,
        );
        // product: eq(u, x) * w(x) * (b(x) * \lambda_2)
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.output),
            ],
            &[
                (F::one(), F::zero()),
                (F::one(), F::zero()),
                (lambda_2, F::zero()),
            ],
            r_2,
        );
        // product: eq(u, x) * (1 - w(x)) * a(x)
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.input),
            ],
            &[
                (F::one(), F::zero()),
                (-F::one(), F::one()),
                (F::one(), F::zero()),
            ],
            r_2,
        );
        // product: eq(u, x) * (1 - w(x)) * (-k * b(x))
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.output),
            ],
            &[
                (F::one(), F::zero()),
                (-F::one(), F::one()),
                (-instance.k, F::zero()),
            ],
            r_2,
        );
        // product: eq(u, x) * (1 - w(x)) * (-c(x))
        poly.add_product_with_linear_op(
            [
                Rc::clone(&identity_func_at_u),
                Rc::clone(&instance.option),
                Rc::clone(&instance.offset),
            ],
            &[
                (F::one(), F::zero()),
                (-F::one(), F::one()),
                (-F::one(), F::zero()),
            ],
            r_2,
        );

        RoundIOPProof {
            bit_decomp_proof_output: BitDecomposition::prove(
                trans,
                &instance.output_bits,
                u,
            ),
            bit_decomp_proof_offset: BitDecomposition::prove(
                trans,
                &instance.offset_aux_bits,
                u,
            ),
            sumcheck_msg: MLSumcheck::prove(trans, &poly)
                .expect("sumcheck for round operation failed")
                .0,
        }
    }

    /// verify
    pub fn verify(proof: &RoundIOPProof<F>, info: &RoundInstanceInfo<F>) -> RoundIOPSubclaim<F> {
        let mut trans = Transcript::<F>::new();
        Self::verify_as_subprotocol(&mut trans, proof, info)
    }

    /// verify with given rng
    pub fn verify_as_subprotocol(
        trans: &mut Transcript<F>,
        proof: &RoundIOPProof<F>,
        info: &RoundInstanceInfo<F>,
    ) -> RoundIOPSubclaim<F> {
        let num_vars = info.output_bits_info.num_vars;
        assert_eq!(num_vars, info.offset_bits_info.num_vars);
        let uniform = <FieldUniformSampler<F>>::new();
        // randomly combine two sumcheck protocols
        let r = trans.get_vec_challenge(b"randomness for sumcheck", 2);
        let r_1 = r[0];
        let r_2 = r[1];

        let poly_info = PolynomialInfo {
            max_multiplicands: 3,
            num_variables: num_vars,
        };
        RoundIOPSubclaim {
            bit_decomp_output_subclaim: BitDecomposition::verifier(
                trans,
                &proof.bit_decomp_proof_output,
                &info.output_bits_info,
            ),
            bit_decomp_offset_subclaim: BitDecomposition::verifier(
                trans,
                &proof.bit_decomp_proof_offset,
                &info.offset_bits_info,
            ),
            sumcheck_subclaim: MLSumcheck::verify(
                trans,
                &poly_info,
                F::zero(),
                &proof.sumcheck_msg,
            )
            .expect("sumcheck protocol for round operation failed"),
            randomness: (r_1, r_2),
        }
    }
}
