//! PIOP for NTT (The algorithm is derived from Chap3.1 in zkCNN: https://eprint.iacr.org/2021/673)
//! The prover wants to convince that Number Theoretic Transform (NTT) algorithm.
//! NTT is widely used for the multiplication of two polynomials in field.
//! 
//! The goal of this IOP is to prove:
//!
//! Given M instances of addition in Zq, the main idea of this IOP is to prove:
//! For y \in \{0, 1\}^N:
//!     $$a(y) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(y, x) }$$
//! where c represents the coefficients of a degree-{N-1} polynomial and a represents the evaulations at (ω^1, ω^3, ..., ω^{2N-1}),
//! 
//! Here ω is the primitive 2N-th root of unity such that ω^{2N} = 1.
//! F is the standard Fourier matrix with only 2N distinct values and F(y, x) = ω^{(2Y-1)X} where Y and X are the field representations for the binary representations y and x, respectively. 
//! 
//! The LHS and RHS of the above equation are both MLE for y, so it can be reduced to check at a random point due to Schwartz-Zippel Lemma.
//! The remaining thing is to prove $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$ with the sumcheck protocol
//! where u is the random challenge from the verifier.

use std::marker::PhantomData;
use std::rc::Rc;
use crate::sumcheck::prover::ProverState;
use crate::sumcheck::verifier::SubClaim;
use crate::sumcheck::{prover::ProverMsg, Proof};
use crate::sumcheck::{self, MLSumcheck};
use crate::utils::{eval_identity_function, gen_identity_evaluations};

use algebra::{
    DenseMultilinearExtension, Field, ListOfProductsOfPolynomials, MultilinearExtension, PolynomialInfo,
    FieldUniformSampler,
};
use rand_distr::Distribution;
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha12Rng;

/// SNARKs for NTT, i.e. $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
pub struct NTTIOP<F: Field>(#[doc(hidden)] PhantomData<F>);

/// proof generated by prover
pub struct NTTProof<F: Field> {
    /// sumcheck proof for $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
    pub first_sumcheck_msg: Vec<ProverMsg<F>>,
    ///
    pub first_claimed_sum: F,
    ///
    pub rounds_sumcheck_msgs: Vec<Proof<F>>,
    /// claimed_sum
    pub rounds_claimed_sums: Vec<F>,
    ///
    pub final_claim: F,
}

/// subclaim returned to verifier
pub struct NTTSubclaim<F: Field> {
    /// claimed sum s.t a[u] = claimed_sum
    pub claimed_sum: F,
    /// subcliam for \sum_{x} c(x)\cdot F(u, x) = claimed_sum
    pub sumcheck_point: Vec<F>,
    ///
    pub first_claim: F,
    /// expected value returned in the last round of the sumcheck
    pub sumcheck_expected_evaluations: F,
    // pub rounds_subclaims: Vec<SubClaim<F>>,
    ///
    pub final_claim: F,
    ///
    pub final_point: Vec<F>,
}

/// proof generated by prover in bare ntt, which only consists of the sumcheck without delegation for F(u, v)
/// Without delegation, prover only needs to prove this sum
/// $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
/// where u is a random point, given by verifier
pub struct NTTProofBare<F: Field> {
    /// sumcheck_msg when proving
    pub sumcheck_msg: Vec<ProverMsg<F>>,
    /// the claimed sum is a(u)
    pub claimed_sum: F,
}

/// subclaim returned in bare ntt, which only consists of the sumcheck without delegation for F(u, v)
/// Without delegation, prover only needs to prove this sum
/// $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
/// where u is a random point, given by verifier
pub struct NTTSubclaimBare<F: Field> {
    /// the claimed sum is a(u)
    pub claimed_sum: F,
    /// the proof is reduced to the evaluation of this point (denoted by v) 
    pub point: Vec<F>,
    /// the proof is reduced to the evaluation equals to c(v) \cdot F(u, v)
    pub expected_evaluation: F,
}

/// Stores the NTT instance with the corresponding NTT table
pub struct NTTInstance<F: Field> {
    /// log_n is the number of the variables 
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Vec<F>,
    /// coefficient representation of the polynomial
    pub coeffs: Rc<DenseMultilinearExtension<F>>,
    /// point-evaluation representation of the polynomial
    pub points: Rc<DenseMultilinearExtension<F>>,
}

/// Stores the corresponding NTT table for the verifier
pub struct NTTInstanceInfo<F: Field> {
    /// log_n is the number of the variables 
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Vec<F>,
}

/// Naive implementation for initializing F(u, x) in NTT (derived from zkCNN: https://eprint.iacr.org/2021/673)
/// 
/// In NTT, the Fourier matrix is different since we choose these points: ω^1, ω^3, ..., ω^{2N-1}
/// Compared to the original induction, the main differences here are F(y, x)  = ω^{(2Y-1) * X} and Y = \sum_{i = 0} y_i * 2^i.
/// The latter one indicates that we use little-endian.
/// * As a result, the equation (8) in zkCNN is = ω^X * \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X})
pub fn naive_init_fourier_table<F: Field>(u: &[F], ntt_table: &[F]) -> DenseMultilinearExtension<F> {
    let dim = u.len();
    let M = ntt_table.len(); // M = 2N = 2 * (1 << dim)

    let mut evaluations: Vec<_> = (0..(1 << dim)).map(|_| F::ONE).collect();

    for x in 0..(1 << dim) {
        for i in 0..dim {
            let idx = (1 << (i + 1)) * x % M;

            let x_i = (x >> i) & 1;
            let x_i_idx = (1 << i) * x_i;
            // evaluations[x] *= (F::ONE - u[i]) + u[i] * power_of_roots[idx];
            evaluations[x] *= ( (F::ONE - u[i]) + u[i] * ntt_table[idx] ) * ntt_table[x_i_idx];
        }
        // evaluations[x] *= power_of_roots[x];
    }

    DenseMultilinearExtension::from_evaluations_vec(dim, evaluations)
}

/// Generate MLE for the Fourier function F(u, x) for x \in \{0, 1\}^dim where u is the random point.
/// Dynamic programming implementaion for initializing F(u, x) in NTT (derived from zkCNN: https://eprint.iacr.org/2021/673)
/// `N` is the dimension of the vector used to represent the polynomial in NTT.
/// 
/// In NTT, the Fourier matrix is different since we choose these points: ω^1, ω^3, ..., ω^{2N-1}
/// Compared to the original induction, the main differences here are F(y, x)  = ω^{(2Y-1) * X} and Y = \sum_{i = 0} y_i * 2^i.
/// The latter one indicates that we use little-endian.
/// * As a result, the equation (8) in zkCNN is = ω^X * \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X})
/// * (This function is the dynamic programming version of the above function.)
/// 
/// * u: the random point
/// * ω: It stores the NTT table: ω^0, ω^1, ..., ω^{2N - 1}
pub fn init_fourier_table<F: Field>(u: &[F], ntt_table: &[F]) -> (Vec<Rc<DenseMultilinearExtension<F>>>, Vec<Rc<DenseMultilinearExtension<F>>>) {
    let log_n = u.len(); // N = 1 << dim
    let M = ntt_table.len(); // M = 2N = 2 * (1 << dim)

    // It store the evaluations of all F(u, x) for x \in \{0, 1\}^dim.
    // Note that in our implementation, we use little endian form, so the index `0b1011`
    // represents the point `P(1,1,0,1)` in {0,1}^`dim`
    let mut evaluations: Vec<_> = vec![F::ZERO; 1 << log_n];
    evaluations[0] = F::ONE;

    let mut rounds_evaluations = Vec::with_capacity(log_n);
    let mut rounds_evaluations_w_term = Vec::with_capacity(log_n);
    // * Compute \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X})
    // The reason why we update the table with u_i in reverse order is that
    // in round i, ω^{2^{i + 1} is the (M / (2^{i+1}))-th root of unity, e.g. i = dim - 1, ω^{2^{i + 1} is the 2-th root of unity.
    // Hence, we need to align this with the update method in dynamic programming.
    for i in (0..log_n).rev() {
        let this_round_dim = log_n - i;
        let last_round_dim = this_round_dim - 1;
        let this_round_table_size = 1 << this_round_dim;
        let last_round_table_size = 1 << (this_round_dim - 1);

        let mut evaluations_w_term = vec![F::ZERO; this_round_table_size];
        for x in (0..this_round_table_size).rev() {
            // idx is to indicate the power ω^{2^{i + 1} * X}
            let idx = (1 << (i + 1)) * x % M;
            // let x_i = (x >> (this_round_dim - 1)) & 1;
            if x >= last_round_table_size {
                evaluations[x] = evaluations[x % last_round_table_size] * (F::ONE - u[i] + u[i] * ntt_table[idx]) * ntt_table[1 << last_round_dim];
            }
            else {
                evaluations[x] = evaluations[x % last_round_table_size] * (F::ONE - u[i] + u[i] * ntt_table[idx]);
            }
            // evaluations[x] = evaluations[x % last_round_table_size] * (F::ONE - u[i] + u[i] * power_of_roots[idx]);
            evaluations_w_term[x] = ntt_table[idx];
        }
        rounds_evaluations.push(Rc::new(DenseMultilinearExtension::from_evaluations_slice(this_round_dim, &evaluations[..this_round_table_size])));
        rounds_evaluations_w_term.push(Rc::new(DenseMultilinearExtension::from_evaluations_vec(this_round_dim, evaluations_w_term)));
    }

    (rounds_evaluations, rounds_evaluations_w_term)
    // * Compute ω^X * \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X})
    // for i in 0..(1 << dim) {
    //     evaluations[i] *= power_of_roots[i % M];
    // }
    // DenseMultilinearExtension::from_evaluations_vec(log_n, evaluations)
}

/// Compute the mle of w^{2^exp \cdot x} for x \in \{0, 1\}^x_dim in a naive method
/// * ntt_table: NTT table for w (M-th root of unity) containing {1, w, w^1, ..., w^{M-1}}
/// * logM: log of M
/// * x_dim: dimension of x or the num of variables of the outputted mle
/// * exp: the exponent of the function defined above
pub fn naive_w_power_times_x_table<F: Field>(ntt_table: &[F], logM: usize, x_dim: usize, exp: usize) -> DenseMultilinearExtension<F> {
    let m = 1 << logM; // M = 2N = 2 * (1 << dim)
    assert_eq!(ntt_table.len(), m);

    let mut evaluations: Vec<_> = (0..(1 << x_dim)).map(|_| F::ONE).collect();
    for x in 0..(1 << x_dim) {
        evaluations[x] = ntt_table[(1 << exp) * x % m];
    }
    DenseMultilinearExtension::from_evaluations_vec(x_dim, evaluations)
}

/// Evaluate the mle w^{2^exp * x} for a random point r \in F^{x_dim}
/// This algorithm is also derived from the techniques in zkCNN.
/// w^{2^exp * r} = \sum_x eq(x, r) *  w^{2^exp * x}
///               = \prod_i (1 - r_i + r_i * w^{2^ {(exp + i) % logM})
/// * Note that the above equation only holds for exp <= logM - x_dim; 
/// * otherwise, the exponent 2^exp * x involves a modular addition, disabling the decomposition.
/// (Although I am not clearly making it out, the experiement result shows the above argument.)
/// 
/// * ntt_table: NTT table for w (M-th root of unity) containing {1, w, w^1, ..., w^{M-1}}
/// * logM: log of M
/// * x_dim: dimension of x or the num of variables of the outputted mle
/// * exp: the exponent of the function defined above
/// * r: random point in F^{x_dim}
pub fn eval_w_power_times_x<F: Field>(ntt_table: &[F], logM: usize, x_dim: usize, exp: usize, r: &[F]) -> F {
    assert_eq!(ntt_table.len(), 1 << logM);
    assert_eq!(x_dim, r.len());
    assert!(exp + x_dim <= logM);
    let mut prod = F::ONE;

    for i in 0..x_dim {
        let log_exp = (exp + i) % logM;
        prod *= F::ONE - r[i] + r[i] * ntt_table[1 << log_exp];
    }

    prod
}

impl<F: Field> NTTInstance<F> {
    /// Extract the information of the NTT Instance for verification
    #[inline]
    pub fn info(&self) -> NTTInstanceInfo<F> {
        NTTInstanceInfo {
            log_n: self.log_n,
            ntt_table: self.ntt_table.clone(),
        }
    }

    /// Constuct a new instance from vector
    #[inline]
    pub fn from_vec(
        log_n: usize,
        ntt_table: Vec<F>,
        coeffs: &Rc<DenseMultilinearExtension<F>>,
        points: &Rc<DenseMultilinearExtension<F>>,
    ) -> Self {
        Self{
            log_n,
            ntt_table,
            coeffs: Rc::clone(&coeffs),
            points: Rc::clone(&points),
        }
    }

    /// Constuct a new instance from slice
    #[inline]
    pub fn from_slice(
        log_n: usize,
        ntt_table: &Vec<F>,
        coeffs: &Rc<DenseMultilinearExtension<F>>,
        points: &Rc<DenseMultilinearExtension<F>>,
    ) -> Self {
        Self{
            log_n,
            ntt_table: ntt_table.clone(),
            coeffs: Rc::clone(&coeffs),
            points: Rc::clone(&points),
        }
    }
}

impl<F: Field> NTTSubclaim<F> {
    /// verify the subcliam
    #[inline]
    pub fn verify_subcliam(
        &self,
        // fourier_matrix: &DenseMultilinearExtension<F>,
        points: &DenseMultilinearExtension<F>,
        coeffs: &DenseMultilinearExtension<F>,
        u: &[F],
        info: &NTTInstanceInfo<F>,
    ) -> bool {
        assert_eq!(u.len(), info.log_n);

        // check the claimed sum is correct
        if self.claimed_sum != points.evaluate(u) {
            return false;
        }
        
        // check the final claim returned from the last sumcheck
        if self.sumcheck_expected_evaluations != coeffs.evaluate(&self.sumcheck_point) * self.first_claim {
            return false;
        }

        let idx = 1 << (info.log_n);
        let eval = eval_identity_function(&self.final_point, &[F::ZERO])
            + eval_identity_function(&self.final_point, &[F::ONE]) * (F::ONE - u[info.log_n - 1] + u[info.log_n - 1] * info.ntt_table[idx]) * info.ntt_table[1];

        self.final_claim == eval
    }
}

impl<F: Field> NTTIOP<F> {
    /// prove 
    pub fn prove(
        ntt_instance: &NTTInstance<F>,
        u: &[F],
    ) -> NTTProof<F> {
        let seed: <ChaCha12Rng as SeedableRng>::Seed = Default::default();
        let mut fs_rng = ChaCha12Rng::from_seed(seed);
        Self::prove_as_subprotocol(&mut fs_rng, ntt_instance, u)
    }

    ///
    pub fn prove_round(
        fs_rng: &mut impl RngCore,
        round: usize,
        point: &[F],
        u_i: F,
        w_coeff: F,
        f: &Rc<DenseMultilinearExtension<F>>,
        w: &Rc<DenseMultilinearExtension<F>>,
    ) -> (Proof<F>, ProverState<F>) {
        assert_eq!(f.num_vars, round);
        assert_eq!(w.num_vars, round + 1);

        let mut poly = <ListOfProductsOfPolynomials<F>>::new(round);
        let mut product_left = Vec::with_capacity(3);
        let mut product_right_round = Vec::with_capacity(3);
        let mut ops_left_round = Vec::with_capacity(3);
        let mut ops_right_round = Vec::with_capacity(3);

        let eq_func = gen_identity_evaluations(&point);
        let (eq_func_left, eq_func_right) = eq_func.split_halves();
        
        let (w_left, w_right) = w.split_halves();

        product_left.push(Rc::new(eq_func_left));
        ops_left_round.push((F::ONE, F::ZERO));
        product_left.push(Rc::clone(f));
        ops_left_round.push((F::ONE, F::ZERO));
        product_left.push(Rc::new(w_left));
        ops_left_round.push((u_i, F::ONE - u_i));
        poly.add_product_with_linear_op(product_left, &ops_left_round, F::ONE);
        
        product_right_round.push(Rc::new(eq_func_right));
        ops_right_round.push((F::ONE, F::ZERO));
        product_right_round.push(Rc::clone(f));
        ops_right_round.push((F::ONE, F::ZERO));
        product_right_round.push(Rc::new(w_right));
        ops_right_round.push((u_i, F::ONE - u_i));
        poly.add_product_with_linear_op(product_right_round, &ops_right_round, w_coeff);
        
        MLSumcheck::prove_as_subprotocol(fs_rng, &poly)
            .expect("ntt proof failed in round {round}")
    }

    /// prove 
    pub fn prove_as_subprotocol(
        fs_rng: &mut impl RngCore,
        ntt_instance: &NTTInstance<F>,
        u: &[F],
    ) -> NTTProof<F> {
        let log_n = ntt_instance.log_n;

        let mut poly = <ListOfProductsOfPolynomials<F>>::new(log_n);

        let mut product = Vec::with_capacity(2);

        let (evals_f, evals_w) = init_fourier_table(&u, &ntt_instance.ntt_table);
        product.push(Rc::clone(&evals_f[log_n - 1]));
        product.push(Rc::clone(&ntt_instance.coeffs));
        poly.add_product(product, F::ONE);

        let first_claimed_sum = ntt_instance.points.evaluate(&u);
        let (first_sumcheck_msg, state) = MLSumcheck::prove_as_subprotocol(fs_rng, &poly)
        .expect("ntt proof failed in the first sumcheck protocol");

        let mut requested_point = state.randomness;
        let mut asserted_eval = evals_f[log_n - 1].evaluate(&requested_point);
        
        let mut rounds_sumcheck_msgs = Vec::with_capacity(log_n - 1);
        let mut rounds_claimed_sums = Vec::with_capacity(log_n - 1);
        for k in (1..log_n).rev() { // start form log_n - 1;
            let i = log_n - 1 - k;
            rounds_claimed_sums.push(asserted_eval);

            let w_coeff = ntt_instance.ntt_table[1 << k];
            let f = &evals_f[k-1];
            let (proof_round, state_round) = Self::prove_round(
                fs_rng, 
                k, 
                &requested_point, 
                u[i], 
                w_coeff, 
                f,
                &evals_w[k]
            );
            rounds_sumcheck_msgs.push(proof_round);

            requested_point = state_round.randomness;
            asserted_eval = f.evaluate(&requested_point);
        }
        
        NTTProof {
            first_claimed_sum,
            first_sumcheck_msg,
            rounds_sumcheck_msgs,
            rounds_claimed_sums,
            final_claim: asserted_eval,
        }
        // NTTProof {
        //     sumcheck_msg: MLSumcheck::prove_as_subprotocol(fs_rng, &poly)
        //     .expect("ntt proof failed").0,
        //     claimed_sum: ntt_instance.points.evaluate(&u),
        // }
        // todo!()
    }

    /// verify
    pub fn verifier(
        proof: &NTTProof<F>,
        ntt_instance_info: &NTTInstanceInfo<F>,
        u: &[F],
    ) -> NTTSubclaim<F> {
        let seed: <ChaCha12Rng as SeedableRng>::Seed = Default::default();
        let mut fs_rng = ChaCha12Rng::from_seed(seed);
        Self::verifier_as_subprotocol(&mut fs_rng, proof, ntt_instance_info, u)
    }

    ///
    pub fn verifiy_reduced_subclaim(
        x_b: &[F],
        subclaim: &SubClaim<F>,
        round: usize,
        u_i: F,
        reduced_claim: F,
        ntt_instance_info: &NTTInstanceInfo<F>,
    ) -> bool {

        let exp = ntt_instance_info.log_n - round;
        let mut r_left: Vec<_> = Vec::with_capacity(round + 1);
        let mut r_right: Vec<_> = Vec::with_capacity(round + 1);
        r_left.extend(&subclaim.point);
        r_right.extend(&subclaim.point);
        r_left.push(F::ZERO);
        r_right.push(F::ONE);

        let w_left = eval_w_power_times_x(&ntt_instance_info.ntt_table, ntt_instance_info.log_n + 1, round + 1, exp, &r_left);
        let w_right = eval_w_power_times_x(&ntt_instance_info.ntt_table, ntt_instance_info.log_n + 1, round + 1, exp, &r_right);
        let eval = eval_identity_function(x_b, &r_left) * reduced_claim * (F::ONE - u_i + u_i * w_left) +
            eval_identity_function(x_b, &r_right) * reduced_claim * (F::ONE - u_i + u_i * w_right) * ntt_instance_info.ntt_table[1 << round];
        
        eval == subclaim.expected_evaluations
    }

    /// verify
    pub fn verifier_as_subprotocol(
        fs_rng: &mut impl RngCore,
        proof: &NTTProof<F>,
        ntt_instance_info: &NTTInstanceInfo<F>,
        u: &[F],
    ) -> NTTSubclaim<F> {
        let log_n = ntt_instance_info.log_n;
        assert_eq!(proof.rounds_sumcheck_msgs.len(), log_n - 1);
        assert_eq!(proof.rounds_claimed_sums.len(), log_n - 1);

        // TODO sample randomness via Fiat-Shamir RNG
        let poly_info = PolynomialInfo {
            max_multiplicands: 2,
            num_variables: ntt_instance_info.log_n,
        };
        let subclaim = MLSumcheck::verify_as_subprotocol(fs_rng, &poly_info, proof.first_claimed_sum, &proof.first_sumcheck_msg)
            .expect("ntt verification failed");


        // let mut rounds_subclaims = Vec::with_capacity(log_n - 1);
        let mut last_point = subclaim.point.clone();
        for (cnt, k, ) in (1..log_n).rev().enumerate() {
            let i = log_n - 1 - k;
            let round_poly_info = PolynomialInfo {
                max_multiplicands: 3,
                num_variables: k,
            };
            let round_subclaim = MLSumcheck::verify_as_subprotocol(fs_rng, &round_poly_info,  proof.rounds_claimed_sums[cnt], &proof.rounds_sumcheck_msgs[cnt])
            .expect("ntt verification failed in round {cnt}");
            let reduced_claim = if cnt < log_n - 2 {
                proof.rounds_claimed_sums[cnt + 1] 
            } else {
                proof.final_claim 
            };
            if !Self::verifiy_reduced_subclaim(&last_point, &round_subclaim, k, u[i], reduced_claim, ntt_instance_info){
                panic!("ntt verification failed in round {cnt}");
            }
            last_point = round_subclaim.point;
        }
        
        assert_eq!(last_point.len(), 1);
        NTTSubclaim {
            claimed_sum: proof.first_claimed_sum,
            // rounds_subclaims,
            sumcheck_point: subclaim.point,
            sumcheck_expected_evaluations: subclaim.expected_evaluations,
            first_claim: proof.rounds_claimed_sums[0],
            final_claim: proof.final_claim,
            final_point: last_point,
        }
    }
}

#[cfg(test)]
mod test {
    use rand::thread_rng;
    use rand_distr::Distribution;
    use algebra::{
        derive::{Field, Prime, NTT}, DenseMultilinearExtension, Field, FieldUniformSampler, MultilinearExtension, NTTField
    };
    use crate::piop::ntt::{naive_w_power_times_x_table, eval_w_power_times_x};

    use super::{naive_init_fourier_table, init_fourier_table};

    macro_rules! field_vec {
        ($t:ty; $elem:expr; $n:expr)=>{
            vec![<$t>::new($elem);$n]
        };
        ($t:ty; $($x:expr),+ $(,)?) => {
            vec![$(<$t>::new($x)),+]
        }
    }

    #[derive(Field, Prime, NTT)]
    #[modulus = 132120577]
    pub struct Fp32(u32);
    // field type
    type FF = Fp32;

    #[test]
    fn test_naive_init_fourier_matrix() {
        let dim = 2;
        let M = 1 << (dim + 1); // M = 2N = 2 * (1 << dim)
        let u = field_vec!(FF; 1, 1);
        let v = field_vec!(FF; 0, 1);
        
        let mut u_v = Vec::with_capacity(dim<<1);
        u_v.extend(&u);
        u_v.extend(&v);

        // root is the M-th root of unity
        let root = FF::try_minimal_primitive_root(M).unwrap();

        let mut fourier_matrix: Vec<_> = (0..(1 << dim) * (1 << dim)).map(|_| FF::ZERO).collect();
        let mut ntt_table = Vec::with_capacity(M as usize);
    
        let mut power = FF::ONE;
        for _ in 0..M {
            ntt_table.push(power);
            power *= root;
        }

        // In little endian, the index for F[i, j] is i + (j << dim)
        for i in 0..1<<dim {
            for j in 0..1<<dim {
                let idx_power = (2 * i + 1) * j % M;
                let idx_fourier = i + (j << dim);
                fourier_matrix[idx_fourier as usize] = ntt_table[idx_power as usize];
            }
        }

        let fourier_mle = DenseMultilinearExtension::from_evaluations_vec(dim << 1, fourier_matrix);
        let partial_fourier_mle = naive_init_fourier_table(&u, &ntt_table);

        assert_eq!(fourier_mle.evaluate(&u_v), partial_fourier_mle.evaluate(&v));
    }

    #[test]
    fn test_init_fourier_matrix() {
        let sampler = <FieldUniformSampler<FF>>::new();
        let mut rng = thread_rng();

        let dim = 10;
        let M = 1 << (dim + 1); // M = 2N = 2 * (1 << dim)
        let u: Vec<_> = (0..dim).map(|_| sampler.sample(&mut rng)).collect();
        let v: Vec<_> = (0..dim).map(|_| sampler.sample(&mut rng)).collect();
        
        let mut u_v: Vec<_> = Vec::with_capacity(dim<<1);
        u_v.extend(&u);
        u_v.extend(&v);

        // root is the M-th root of unity
        let root = FF::try_minimal_primitive_root(M).unwrap();

        let mut fourier_matrix: Vec<_> = (0..(1 << dim) * (1 << dim)).map(|_| FF::ZERO).collect();
        let mut ntt_table = Vec::with_capacity(M as usize);
    
        let mut power = FF::ONE;
        for _ in 0..M {
            ntt_table.push(power);
            power *= root;
        }

        // In little endian, the index for F[i, j] is i + (j << dim)
        for i in 0..1<<dim {
            for j in 0..1<<dim {
                let idx_power = (2 * i + 1) * j % M;
                let idx_fourier = i + (j << dim);
                fourier_matrix[idx_fourier as usize] = ntt_table[idx_power as usize];
            }
        }

        let fourier_mle = DenseMultilinearExtension::from_evaluations_vec(dim << 1, fourier_matrix);
        let partial_fourier_mle = &init_fourier_table(&u, &ntt_table).0[dim - 1];

        assert_eq!(fourier_mle.evaluate(&u_v), partial_fourier_mle.evaluate(&v));
    }

    #[test]
    fn test_w_power_x() {
        let dim = 10; // meaning x\in \{0, 1\}^{dim} and N = 1 << dim
        let logM = dim + 1;
        let M = 1 << logM; // M = 2N

        // root is the M-th root of unity
        let root = FF::try_minimal_primitive_root(M).unwrap();

        let mut ntt_table = Vec::with_capacity(M as usize);
    
        let mut power = FF::ONE;
        for _ in 0..M {
            ntt_table.push(power);
            power *= root;
        }

        let sampler = <FieldUniformSampler<FF>>::new();
        let mut rng = thread_rng();

        
        for x_dim in 0..=dim {
            let max_exp = logM - x_dim;
            for exp in 0..=max_exp {
                let r: Vec<_> = (0..x_dim).map(|_| sampler.sample(&mut rng)).collect();
                let w_mle = naive_w_power_times_x_table(&ntt_table, logM, x_dim, exp);
                let w_eval = eval_w_power_times_x(&ntt_table, logM, x_dim, exp, &r);
                assert_eq!(w_eval, w_mle.evaluate(&r));
            }
        }
    }
}