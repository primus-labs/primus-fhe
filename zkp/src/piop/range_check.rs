//! PIOP for range check
//! The prover wants to convince that lookups f are all in range
//!
//! <==> \forall x \in H_f, \forall i \in [lookup_num], f_i(x) \in [range]
//!
//! <==> \forall x in H_f, \forall i \in [lookup_num], f_i(x) \in {t(x) | x \in H_t} := {0, 1, 2, ..., range - 1}  
//!      where |H_f| is the size of one lookup and |H_t| is the size of table / range
//!
//! <==> \exists m s.t. \forall y, \sum_{i} \sum_{x \in H_f} 1 / f_i(x) - y = \sum_{x \in H_t} m(x) / t(x) - y
//!
//! <==> \sum_{i} \sum_{x \in H_f} 1 / f_i(x) - r = \sum_{x \in H_t} m(x) / t(x) - r
//!      where r is a random challenge from verifier (a single random element since y is a single variable)
//!
//! <==> \sum_{x \in H_f} \sum_{i \in [block_num]} h_i(x) = \sum_{x \in H_t} h_t(x)
//!      \forall i \in [block_num] \forall x \in H_f, h(x) * \prod_{j \in [block_size]}(f_j(x) - r) = \sum_{i \in [block_size]} \prod_{j \in [block_size], j != i} (f_j(x) - r)
//!      \forall x \in H_t, h_t(x) * (t(x) - r) = m(x)
//!
//! <==> \sum_{x \in H_f} \sum_{i \in [block_num]} h_i(x) = c_sum
//!      \sum_{x \in H_t} h_t(x) = c_sum
//!      \sum_{x \in H_f} \sum_{i \in [block_num]} eq(x, u) * (h(x) * \prod_{j \in [block_size]}(f_j(x) - r) - r * \sum_{i \in [block_size]} \prod_{j \in [block_size], j != i} (f_j(x) - r)) = 0
//!      \sum_{x \in H_t} eq(x, u) * (h_t(x) * (t(x) - r) - m(x)) = 0
//!      where u is a random challenge given from verifier (a vector of random element) and c_sum is some constant
//!
//! <==> \sum_{x \in H_f} \sum_{i \in [block_num]} h_i(x)
//!                     + \sum_{i \in [block_num]} eq(x, u) * (h(x) * \prod_{j \in [block_size]}(f_j(x) - r) - r * \sum_{i \in [block_size]} \prod_{j \in [block_size], j != i} (f_j(x) - r))
//!                     = c_sum
//!      \sum_{x \in H_t} h_t(x)
//!                     + eq(x, u) * (h_t(x) * (t(x) - r) - m(x))
//!                     = c_sum
//!      where u is a random challenge given from verifier (a vector of random element) and c_sum is some constant

use std::marker::PhantomData;
use std::rc::Rc;

use crate::sumcheck::prover::ProverMsg;
use crate::utils::eval_identity_function;

use crate::sumcheck::MLSumcheck;
use crate::utils::{batch_inverse, gen_identity_evaluations};
use algebra::{
    AsFrom, DecomposableField, DenseMultilinearExtension, Field, FieldUniformSampler,
    ListOfProductsOfPolynomials, MultilinearExtension, PolynomialInfo,
};
use rand::RngCore;
use rand_distr::Distribution;

/// SNARKs for range check in [T] := [0, T-1]
pub struct Lookup<F: Field>(PhantomData<F>);

/// proof generated by prover
pub struct LookupProof<F: Field> {
    /// sumcheck proof for
    /// \sum_{x\in H_F} f_inverse(x) = c_sum
    /// \sum_{x\in H_T} t_inverse(x) = c_sum
    /// \sum_{x\in H_F} eq(x, u) f_inverse(x) (r - f(x)) = 1
    /// \sum_{x\in H_T} eq(x, u) (t_inverse(x) (r - t(x)) - m(x)) = 0
    /// where H_F := {0, 1}^log(|F|), H_T := {0, 1}^log(|T|)
    pub sumcheck_msg: Vec<Vec<ProverMsg<F>>>,
    // c_sum
    //pub c_sum: F,
}

/// oracles
#[derive(Clone)]
pub struct LookupOracle<F: Field> {
    /// f_inverse
    pub h_vec: Vec<Rc<DenseMultilinearExtension<F>>>,
    /// t_inverse
    //pub h_t: Rc<DenseMultilinearExtension<F>>,
    /// m
    pub m: Rc<DenseMultilinearExtension<F>>,
}

/// subclaim returned to verifier
pub struct LookupSubclaim<F: Field> {
    /// random value
    pub random_value: F,
    /// random point
    pub random_point: Vec<F>,
    /// random combine
    pub random_combine: Vec<F>,
    /// subcliams
    pub sumcheck_points: Vec<Vec<F>>,
    /// expected value returned in the last round of the sumcheck
    pub sumcheck_expected_evaluations: Vec<F>,
}

/// Stores the parameters used for range check in [T] and the inputs and witness for prover.
pub struct LookupInstance<F: Field> {
    /// number of variables for lookups i.e. the size of log(|F|)
    pub num_vars: usize,
    // number of variables for range,
    //pub num_vars_t: usize,
    /// block_size
    pub block_size: usize,
    // range
    //pub range: usize,
    /// inputs f
    pub f_vec: Vec<Rc<DenseMultilinearExtension<F>>>,
    /// inputs t
    pub t: Rc<DenseMultilinearExtension<F>>,
}

/// Stores the parameters used for range check in [T] and the public info for verifier.
pub struct LookupInstanceInfo {
    /// number of variables for lookups i.e. the size of log(|F|)
    pub num_vars: usize,
    // number of variables for range,
    //pub num_vars_t: usize,
    // range
    //pub range: usize,
    /// chunk
    pub block_size: usize,
    /// block num
    pub block_num: usize,
    /// residual length
    pub residual_size: usize,
}

impl<F: Field> LookupInstance<F> {
    /// Extract the information of range check for verification
    #[inline]
    pub fn info(&self) -> LookupInstanceInfo {
        let column_num = self.f_vec.len() + 1;
        LookupInstanceInfo {
            num_vars: self.num_vars,
            //num_vars_t: self.num_vars_t,
            // range: self.range,
            block_size: self.block_size,
            block_num: column_num / self.block_size,
            residual_size: column_num % self.block_size,
        }
    }
}

impl<F: Field> LookupInstance<F> {
    /// Construct a new instance from vector
    #[inline]
    pub fn from_vec(
        f: Vec<Rc<DenseMultilinearExtension<F>>>,
        t: Rc<DenseMultilinearExtension<F>>,
        block_size: usize,
    ) -> Self {
        let num_vars_f = f[0].num_vars;
        let num_vars_t = num_vars_f;

        f.iter().for_each(|x| assert_eq!(x.num_vars, num_vars_f));

        let mut t_evaluations = t.evaluations.clone();
        t_evaluations.resize(1 << num_vars_t, F::zero());
        let t = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            num_vars_t,
            t_evaluations,
        ));

        Self {
            num_vars: num_vars_f,
            //num_vars_t,
            block_size,
            f_vec: f,
            t,
        }
    }

    /// Construct a new instance from slice
    #[inline]
    pub fn from_slice(
        f: &[Rc<DenseMultilinearExtension<F>>],
        t: Rc<DenseMultilinearExtension<F>>,
        block_size: usize,
    ) -> Self {
        let num_vars = f[0].num_vars;

        f.iter().for_each(|x| assert_eq!(x.num_vars, num_vars));

        let mut t_evaluations = t.evaluations.clone();
        t_evaluations.resize(1 << num_vars, F::zero());
        let t = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            num_vars,
            t_evaluations,
        ));

        Self {
            num_vars,
            block_size,
            f_vec: f.to_vec(),
            t,
        }
    }
}

impl<F: DecomposableField> Lookup<F> {
    /// verifier challenges.
    pub fn prove(
        fs_rng: &mut impl RngCore,
        instance: &LookupInstance<F>,
    ) -> (LookupProof<F>, LookupOracle<F>) {
        let num_vars = instance.num_vars;
        //let num_vars_t = instance.num_vars_t;
        let column_size = instance.f_vec.len() + 1;
        let block_size = instance.block_size;
        let block_num = column_size / instance.block_size;
        let residual_size = column_size % instance.block_size;

        // prepare randomness
        let sampler = <FieldUniformSampler<F>>::new();
        let random_value = sampler.sample(fs_rng);
        let random_point: Vec<_> = (0..num_vars).map(|_| sampler.sample(fs_rng)).collect();
        let random_combine: Vec<_> = (0..block_num + if residual_size == 0 { 0 } else { 1 } + 1)
            .map(|_| sampler.sample(fs_rng))
            .collect();

        let m_evaluations: Vec<F> = instance
            .t
            .evaluations
            .iter()
            .map(|t_item| {
                let m_f_vec = instance.f_vec.iter().fold(F::zero(), |acc, f| {
                    let m_f: usize = f
                        .evaluations
                        .iter()
                        .filter(|&f_item| f_item == t_item)
                        .count();
                    let m_f: F = F::new(F::Value::as_from(m_f as f64));
                    acc + m_f
                });

                let m_t = instance
                    .t
                    .evaluations
                    .iter()
                    .filter(|&t_item2| t_item2 == t_item)
                    .count();
                let m_t: F = F::new(F::Value::as_from(m_t as f64));

                m_f_vec / m_t
            })
            .collect();

        let m = Rc::new(DenseMultilinearExtension::from_evaluations_slice(
            num_vars,
            &m_evaluations,
        ));

        // integrate t into columns
        let mut ft_vec = instance.f_vec.clone();
        ft_vec.push(instance.t.clone());

        // construct shifted columns: (f(x) - r)
        let shifted_ft_vec: Vec<Rc<DenseMultilinearExtension<F>>> = ft_vec
            .iter()
            .map(|f| {
                let evaluations = f.evaluations.iter().map(|x| *x - random_value).collect();
                Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                    num_vars,
                    evaluations,
                ))
            })
            .collect();

        // construct inversed shifted columns: 1 / (f(x) - r)
        let mut inversed_shifted_ft_evaluation_vec = batch_inverse(
            &shifted_ft_vec
                .iter()
                .flat_map(|f| f.iter())
                .cloned()
                .collect::<Vec<F>>(),
        );

        let total_size = inversed_shifted_ft_evaluation_vec.len();

        inversed_shifted_ft_evaluation_vec[(total_size - (1 << num_vars))..]
            .iter_mut()
            .zip(m_evaluations.iter())
            .for_each(|(inverse_shifted_t, m)| {
                *inverse_shifted_t *= -(*m);
            });

        let chunks = inversed_shifted_ft_evaluation_vec.chunks_exact(block_size * (1 << num_vars));

        let residual = chunks.remainder();

        // construct blocked columns
        let mut h_vec: Vec<Rc<DenseMultilinearExtension<F>>> = chunks
            .map(|block| {
                Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                    num_vars,
                    block.chunks_exact(1 << num_vars).fold(
                        vec![F::zero(); 1 << num_vars],
                        |mut h_evaluations, inversed_shifted_f| {
                            inversed_shifted_f
                                .iter()
                                .enumerate()
                                .for_each(|(idx, &val)| {
                                    h_evaluations[idx] += val;
                                });
                            h_evaluations
                        },
                    ),
                ))
            })
            .collect();

        let h_residual = Rc::new(DenseMultilinearExtension::from_evaluations_vec(
            num_vars,
            residual.chunks_exact(1 << num_vars).fold(
                vec![F::zero(); 1 << num_vars],
                |mut acc, f| {
                    f.iter().enumerate().for_each(|(i, &val)| {
                        acc[i] += val;
                    });
                    acc
                },
            ),
        ));

        if residual_size != 0 {
            h_vec.push(h_residual)
        };

        let mut sum = F::zero();
        h_vec
            .iter()
            .for_each(|h| h.evaluations.iter().for_each(|x| sum += x));

        let mut sumcheck_msg = Vec::new();

        // execute sumcheck for
        // \sum_{x \in H_f}
        //                  r * \sum_{i \in [block_num]} h_i(x)
        //                + \sum_{i \in [block_num]} eq(x, u) * (h(x) * \prod_{j \in [block_size]}(f_j(x) - r) - \sum_{i \in [block_size]} \prod_{j \in [block_size], j != i} (f_j(x) - r))
        //                = c_sum
        let mut poly = <ListOfProductsOfPolynomials<F>>::new(instance.num_vars);
        for ((i, h), u_coef) in h_vec.iter().enumerate().zip(random_combine.iter()) {
            let product = vec![h.clone()];
            let op_coef = vec![(F::one(), F::zero())];
            poly.add_product_with_linear_op(product, &op_coef, F::one());

            let is_last_block = i == h_vec.len() - 1;

            let this_block_size = if is_last_block && (residual_size != 0) {
                residual_size
            } else {
                block_size
            };

            let block = &shifted_ft_vec[i * block_size..i * block_size + this_block_size];
            let id_u = Rc::new(gen_identity_evaluations(&random_point));
            let mut id_op_coef = vec![(F::one(), F::zero()); this_block_size + 2];

            let mut product = block.to_vec();
            product.extend(vec![id_u.clone(), h.clone()]);
            poly.add_product_with_linear_op(product, &id_op_coef, *u_coef);

            id_op_coef.pop();
            id_op_coef.pop();

            for j in 0..this_block_size {
                let mut product = block.to_vec();
                product[j] = id_u.clone();
                if is_last_block && (j == this_block_size - 1) {
                    id_op_coef.push((-F::one(), F::zero()));
                    product.push(m.clone());
                }

                poly.add_product_with_linear_op(product, &id_op_coef, -*u_coef);
            }
        }

        let sumcheck_proof = MLSumcheck::prove_as_subprotocol(fs_rng, &poly)
            .expect("sumcheck for rangecheck failed");
        sumcheck_msg.push(sumcheck_proof.0);

        (LookupProof { sumcheck_msg }, LookupOracle { h_vec, m })
    }

    /// Verify addition in Zq given the proof and the verification key for bit decomposistion
    /// This function does the same thing as `prove`, but it uses a `Fiat-Shamir RNG` as the transcript/to generate the
    /// verifier challenges.
    pub fn verify(
        fs_rng: &mut impl RngCore,
        proof: &LookupProof<F>,
        info: &LookupInstanceInfo,
    ) -> LookupSubclaim<F> {
        let sampler = <FieldUniformSampler<F>>::new();
        let random_value = sampler.sample(fs_rng);
        let random_point: Vec<_> = (0..info.num_vars).map(|_| sampler.sample(fs_rng)).collect();
        let random_combine: Vec<_> =
            (0..info.block_num + if info.residual_size == 0 { 0 } else { 1 } + 1)
                .map(|_| sampler.sample(fs_rng))
                .collect();

        // execute sumcheck for
        // \sum_{x \in H_f}
        // \sum_{i \in [block_num]}  r * h_i(x)
        //                         + \ eq(x, u) * (h(x) * \prod_{j \in [block_size]}(f_j(x) - r)
        //                         - \sum_{i \in [block_size]} \prod_{j \in [block_size], j != i} (f_j(x) - r))
        //                         = c_sum
        let poly_info = PolynomialInfo {
            max_multiplicands: info.block_size + 2,
            num_variables: info.num_vars,
        };
        let first_subclaim = MLSumcheck::verify_as_subprotocol(
            fs_rng,
            &poly_info,
            F::zero(), //proof.c_sum,
            &proof.sumcheck_msg[0],
        )
        .expect("sumcheck protocol in range check failed");

        LookupSubclaim {
            random_value,
            random_point,
            random_combine,
            sumcheck_points: vec![first_subclaim.point], //, second_subclaim.point],
            sumcheck_expected_evaluations: vec![
                first_subclaim.expected_evaluations,
                //second_subclaim.expected_evaluations,
            ],
        }
    }
}

impl<F: Field> LookupSubclaim<F> {
    /// verify the sumcliam
    #[inline]
    #[allow(clippy::too_many_arguments)]
    pub fn verify_subclaim(
        &self,
        f_vec: Vec<Rc<DenseMultilinearExtension<F>>>,
        t: Rc<DenseMultilinearExtension<F>>,
        oracle: LookupOracle<F>,
        info: &LookupInstanceInfo,
    ) -> bool {
        let u_f = &self.random_point;

        let block_size = info.block_size;

        let h_vec = oracle.h_vec;
        //let h_t = oracle.h_t;
        let m = oracle.m;
        let mut ft_vec = f_vec.clone();
        ft_vec.push(t);

        let mut eval = F::zero();
        let point = &self.sumcheck_points[0];

        let m_eval = m.evaluate(point);

        let chunks = ft_vec.chunks_exact(block_size);
        let residual = Some(chunks.remainder()).into_iter();
        //if residual_size != 0 {chunks = chunks.chain(residual);}

        for (i, ((h, f_block), r_k)) in h_vec
            .iter()
            .zip(chunks.chain(residual))
            .zip(self.random_combine.iter())
            .enumerate()
        {
            let is_last_block = i == (h_vec.len() - 1);
            let h_eval = h.evaluate(point);
            let eq_eval = eval_identity_function(u_f, point);

            let shifted_f_eval_block: Vec<F> = f_block
                .iter()
                .map(|f| f.evaluate(point) - self.random_value)
                .collect();
            let sum_of_products: F = (0..shifted_f_eval_block.len())
                .map(|idx: usize| {
                    shifted_f_eval_block
                        .iter()
                        .enumerate()
                        .fold(F::one(), |acc, (i, x)| {
                            let mut mult = F::one();
                            if i != idx {
                                mult *= x;
                            }
                            if is_last_block
                                && (idx == shifted_f_eval_block.len() - 1)
                                && (i == shifted_f_eval_block.len() - 1)
                            {
                                mult *= -m_eval;
                            }
                            acc * mult
                        })
                })
                .fold(F::zero(), |acc, x| acc + x);

            let product = shifted_f_eval_block.iter().fold(F::one(), |acc, x| acc * x);

            eval += h_eval + eq_eval * r_k * (h_eval * product - sum_of_products);
        }

        if eval != self.sumcheck_expected_evaluations[0] {
            return false;
        }

        true
    }
}
