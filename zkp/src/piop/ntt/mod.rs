//! PIOP for NTT with delegation
//! The algorithm is derived from Chap3.1 in zkCNN: https://eprint.iacr.org/2021/673
//! The prover wants to convince that Number Theoretic Transform (NTT) algorithm.
//! NTT is widely used for the multiplication of two polynomials in field.
//!
//! The goal of this IOP is to prove:
//!
//! Given M instances of addition in Zq, the main idea of this IOP is to prove:
//! For y \in \{0, 1\}^N:
//!     $$a(y) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(y, x) }$$
//! where c represents the coefficients of a degree-{N-1} polynomial and a represents the evaulations at (ω^1, ω^3, ..., ω^{2N-1}),
//!
//! Here ω is the primitive 2N-th root of unity such that ω^{2N} = 1.
//! F is the standard Fourier matrix with only 2N distinct values and F(y, x) = ω^{(2Y-1)X} where Y and X are the field representations for the binary representations y and x, respectively.
//!
//! The LHS and RHS of the above equation are both MLE for y, so it can be reduced to check at a random point due to Schwartz-Zippel Lemma.
//! The remaining thing is to prove $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$ with the sumcheck protocol
//! where u is the random challenge from the verifier.
//!
//! Without delegation, the verifier needs to compute F(u, v) on his own using the same algorithm as the prover, which costs O(N).
//! In order to keep a succinct verifier, the computation of F(u, v) can be delegated to prover.
//!
//! We define $A_{F}^{(k)}:\{0,1\}^{k+1} -> \mathbb{F}$ and $ω^{(k)}_{i+1}:\{0,1\}^{k+1} -> \mathbb{F}$.
//! Note that k + i + 1= \log N.
//! In each round, the prover wants to prove, for all $x\in \{0,1\}^i$, b\in \{0,1\}:
//! A_{F}^{(k)}(x, b)=A_{F}^{(k-1)}(x) * (1-u_{i} + u_{i} * \ω^{(k)}_{i+1}(x, b)) * ω^{2^k * b}
//! where $\ω^{(k)}_{i+1}(x,b ) = \ω^{2^{i+1}\cdot j}$ for $j = X+2^{i+1}\cdot b$.
//! So, it is reduced to prove the the following sum = \tilde{A}_{F}^{(k)}(x, b) at a random point $(x, b)\in \mathbb{F}^{k+1}$:
//!     =\sum_{z\in \{0,1\}}^k
//!         \tilde{\beta}((x, b),(z,0)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 0)
//!       + \tilde{\beta}((x, b),(z,1)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 1) * ω^{2^k}

use crate::sumcheck::prover::ProverState;
use crate::sumcheck::verifier::SubClaim;
use crate::sumcheck::MLSumcheck;
use crate::sumcheck::Proof;
use crate::utils::{eval_identity_function, gen_identity_evaluations};
use core::fmt;
use std::marker::PhantomData;
use std::rc::Rc;

use algebra::utils::Transcript;
use algebra::AbstractExtensionField;
use algebra::DenseMultilinearExtensionBase;
use algebra::{
    DenseMultilinearExtension, Field, ListOfProductsOfPolynomials, MultilinearExtension,
    PolynomialInfo, UF,
};

use itertools::izip;
use ntt_bare::{NTTBareIOP, NTTBareProof, NTTBareSubclaim};
use serde::ser::SerializeSeq;
use serde::Serialize;

pub mod ntt_bare;
/// SNARKs for NTT, i.e. $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
pub struct NTTIOP<F: Field, EF: AbstractExtensionField<F>> {
    _marker: PhantomData<F>,
    _stone: PhantomData<EF>,
}

/// proof generated by prover
pub struct NTTProof<F: Field, EF: AbstractExtensionField<F>> {
    /// bare ntt proof for proving $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
    pub ntt_bare_proof: NTTBareProof<F, EF>,
    /// sumcheck proof for $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
    /// collective sumcheck proofs for delegation
    pub delegation_sumcheck_msgs: Vec<Proof<F, EF>>,
    /// collective claimed sums for delegation
    pub delegation_claimed_sums: Vec<EF>,
    /// final claim
    pub final_claim: EF,
}

/// All the proofs generated only in the recursive phase to prove F(u, v), which does not contain the ntt_bare_proof.
#[derive(Serialize)]
pub struct NTTRecursiveProof<F: Field, EF: AbstractExtensionField<F>> {
    /// sumcheck proof for $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
    /// collective sumcheck proofs for delegation
    pub delegation_sumcheck_msgs: Vec<Proof<F, EF>>,
    /// collective claimed sums for delegation
    pub delegation_claimed_sums: Vec<EF>,
    /// final claim
    pub final_claim: EF,
}

/// subclaim returned to verifier
pub struct NTTSubclaim<F: Field, EF: AbstractExtensionField<F>> {
    /// subclaim returned in ntt bare for proving $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
    pub ntt_bare_subclaim: NTTBareSubclaim<F, EF>,
    /// the first claim in the delegation process, i.e. F(u, v)
    pub delegation_first_claim: EF,
    /// the final claim in the delegation process
    pub delegation_final_claim: EF,
    /// the requested point in the final claim
    pub final_point: Vec<EF>,
}

/// Stores the NTT instance with the corresponding NTT table
pub struct NTTInstance<F: Field> {
    /// log_n is the number of the variables
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Rc<Vec<F>>,
    /// coefficient representation of the polynomial
    pub coeffs: DenseMultilinearExtensionBase<F>,
    /// point-evaluation representation of the polynomial
    pub points: DenseMultilinearExtensionBase<F>,
}

/// Store all the NTT instances over Field to be proved, which will be randomized into a single random NTT instance over Extension Field.
pub struct NTTInstances<F: Field> {
    /// number of ntt instances
    pub num_ntt: usize,
    /// number of variables
    pub num_vars: usize,
    /// log_n is the number of the variables
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Rc<Vec<F>>,
    /// store the coefficient representaions
    pub coeffs: Vec<Rc<DenseMultilinearExtensionBase<F>>>,
    /// store the point-evaluation representation
    pub points: Vec<Rc<DenseMultilinearExtensionBase<F>>>,
}

/// Stores the NTT instance with the corresponding NTT table
/// where the NTT instance is generated by random linear combination and the randomness is over EF
pub struct NTTInstanceExt<F: Field, EF: AbstractExtensionField<F>> {
    /// number of instances randomized into this NTT instance
    pub num_instance: usize,
    /// log_n is the number of the variables
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Rc<Vec<F>>,
    /// coefficient representation of the polynomial
    pub coeffs: DenseMultilinearExtension<F, EF>,
    /// point-evaluation representation of the polynomial
    pub points: DenseMultilinearExtension<F, EF>,
}

impl<F: Field> NTTInstances<F> {
    /// Construct an empty container
    #[inline]
    pub fn new(num_vars: usize, log_n: usize, ntt_table: &Rc<Vec<F>>) -> Self {
        Self {
            num_ntt: 0,
            num_vars,
            log_n,
            ntt_table: Rc::clone(ntt_table),
            coeffs: Vec::new(),
            points: Vec::new(),
        }
    }

    /// Extract the information of the NTT Instance for verification
    #[inline]
    pub fn info(&self) -> NTTInstanceInfo<F> {
        NTTInstanceInfo {
            num_ntt: self.num_ntt,
            log_n: self.log_n,
            ntt_table: Rc::clone(&self.ntt_table),
        }
    }

    /// Add a ntt instance into the container
    #[inline]
    pub fn add_ntt(
        &mut self,
        coeff: Rc<DenseMultilinearExtensionBase<F>>,
        point: Rc<DenseMultilinearExtensionBase<F>>,
    ) {
        self.num_ntt += 1;
        assert_eq!(self.num_vars, coeff.num_vars);
        assert_eq!(self.num_vars, point.num_vars);
        self.coeffs.push(coeff);
        self.points.push(point);
    }

    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        self.num_ntt * 2
    }

    /// Pack all the involved small polynomials into a single vector of evaluations.
    /// The arrangement of this packed MLE is not as compact as others.
    /// We deliberately do like this for ease of requested evaluation on the committed polynomial.
    #[inline]
    pub fn pack_all_mles(&self) -> Vec<F> {
        let num_oracles_half = self.num_ntt;
        let num_vars_added_half = num_oracles_half.next_power_of_two().ilog2() as usize;
        let num_zeros_padded_half =
            ((1 << num_vars_added_half) - num_oracles_half) * (1 << self.num_vars);

        // arrangement: all coeffs || padded zeros || all points || padded zeros
        // The advantage of this arrangement is that F(0, x) packs all evaluations of coeff-MLEs and F(1, x) packs all evaluations of point-MLEs
        let padded_zeros = vec![F::zero(); num_zeros_padded_half];
        self.coeffs
            .iter()
            .flat_map(|coeff| coeff.iter())
            .chain(padded_zeros.iter())
            .chain(self.points.iter().flat_map(|point| point.iter()))
            .chain(padded_zeros.iter())
            .copied()
            .collect::<Vec<F>>()
    }

    /// Generate the oracle to be committed that is composed of all the small oracles used in IOP.
    /// The evaluations of this oracle is generated by the evaluations of all mles and the padded zeros.
    /// The arrangement of this oracle should be consistent to its usage in verifying the subclaim.
    #[inline]
    pub fn generate_oracle(&self) -> DenseMultilinearExtensionBase<F> {
        let num_oracles_half = self.num_ntt;
        let num_vars_added_half = num_oracles_half.next_power_of_two().ilog2() as usize;
        let num_vars = self.num_vars + num_vars_added_half + 1;

        // arrangement: all coeffs || padded zeros || all points || padded zeros
        // The advantage of this arrangement is that F(0, x) packs all evaluations of coeff-MLEs and F(1, x) packs all evaluations of point-MLEs
        let evals = self.pack_all_mles();
        <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(num_vars, evals)
    }

    /// Prover needs to compute the evaluations of all the smaller point-MLEs at the random point sampled before the sumcheck protocol.
    #[inline]
    pub fn compute_coeff_evals<EF: AbstractExtensionField<F>>(&self, point: &[EF]) -> Vec<EF> {
        self.coeffs
            .iter()
            .map(|mle| mle.evaluate_ext(point))
            .collect::<Vec<EF>>()
    }

    /// Prover needs to compute the evaluations of all the smaller point-MLEs at the random point sampled before the sumcheck protocol.
    #[inline]
    pub fn compute_point_evals<EF: AbstractExtensionField<F>>(&self, point: &[EF]) -> Vec<EF> {
        self.points
            .iter()
            .map(|mle| mle.evaluate_ext(point))
            .collect::<Vec<EF>>()
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> NTTInstanceExt<F, EF> {
    /// Extract the information of the NTT Instance for verification
    #[inline]
    pub fn info(&self) -> NTTInstanceInfo<F> {
        NTTInstanceInfo {
            num_ntt: self.num_instance,
            log_n: self.log_n,
            ntt_table: Rc::clone(&self.ntt_table),
        }
    }

    /// Construct a new instance from the original instance defined over the basic field
    pub fn from_base(input_base: &NTTInstance<F>) -> Self {
        Self {
            num_instance: 1,
            log_n: input_base.log_n,
            ntt_table: input_base.ntt_table.clone(),
            coeffs: <DenseMultilinearExtension<F, EF>>::from_base(&input_base.coeffs),
            points: <DenseMultilinearExtension<F, EF>>::from_base(&input_base.points),
        }
    }

    /// Constuct a new instance from given info
    #[inline]
    pub fn from_info(info: &NTTInstanceInfo<F>) -> Self {
        Self {
            num_instance: info.num_ntt,
            log_n: info.log_n,
            ntt_table: info.ntt_table.to_owned(),
            coeffs: <DenseMultilinearExtension<F, EF>>::from_evaluations_vec(
                info.log_n,
                vec![EF::zero(); 1 << info.log_n],
            ),
            points: <DenseMultilinearExtension<F, EF>>::from_evaluations_vec(
                info.log_n,
                vec![EF::zero(); 1 << info.log_n],
            ),
        }
    }

    /// Construct a random ntt instances from all the ntt instances to be proved
    pub fn from_base_instances(
        trans: &mut Transcript<F>,
        log_n: usize,
        ntt_table: &Rc<Vec<F>>,
        instances: &NTTInstances<F>,
    ) -> Self {
        let mut random_coeffs = <DenseMultilinearExtension<F, EF>>::from_evaluations_vec(
            log_n,
            vec![EF::zero(); 1 << log_n],
        );
        let mut random_points = <DenseMultilinearExtension<F, EF>>::from_evaluations_vec(
            log_n,
            vec![EF::zero(); 1 << log_n],
        );

        assert_eq!(instances.num_ntt, instances.coeffs.len());
        assert_eq!(instances.num_ntt, instances.points.len());
        let coins = trans.get_vec_ext_field_challenge::<EF>(
            b"Generate random coefficients to randomize all ntt instances",
            instances.num_ntt,
        );

        for (r, coeff, point) in izip!(&coins, &instances.coeffs, &instances.points) {
            random_coeffs += (*r, coeff.as_ref());
            random_points += (*r, point.as_ref());
        }

        Self {
            num_instance: instances.num_ntt,
            log_n,
            ntt_table: ntt_table.to_owned(),
            coeffs: random_coeffs,
            points: random_points,
        }
    }

    /// add ntt_instance
    #[inline]
    pub fn add_ntt(
        &mut self,
        r: EF,
        coeffs: &Rc<DenseMultilinearExtensionBase<F>>,
        points: &Rc<DenseMultilinearExtensionBase<F>>,
    ) {
        self.coeffs += (r, coeffs.as_ref());
        self.points += (r, points.as_ref());
    }
}

/// Stores the corresponding NTT table for the verifier
#[derive(Clone)]
pub struct NTTInstanceInfo<F: Field> {
    /// number of instances randomized into this NTT instance
    pub num_ntt: usize,
    /// log_n is the number of the variables
    /// the degree of the polynomial is N - 1
    pub log_n: usize,
    /// stores {ω^0, ω^1, ..., ω^{2N-1}}
    pub ntt_table: Rc<Vec<F>>,
}

impl<F: Field> fmt::Display for NTTInstanceInfo<F> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "a NTT instance randomized from {} NTT instances",
            self.num_ntt,
        )
    }
}

impl<F: Field> NTTInstanceInfo<F> {
    /// Return the number of small polynomials used in IOP
    #[inline]
    pub fn num_oracles(&self) -> usize {
        self.num_ntt * 2
    }

    /// Return the number of random coins sampled to randomize ntt instances
    #[inline]
    pub fn num_coins(&self) -> usize {
        self.num_ntt
    }

    /// Compute the evaluation over the random point of the polynomial proved in the sumcheck protocol,
    /// which is the random linear combination of the evaluations of all the invloved coefficient-MLEs.
    /// Note that the evaluated point is the random point returned from the sumcheck protocol.
    #[inline]
    pub fn compute_subclaim_eval<EF: AbstractExtensionField<F>>(
        &self,
        coeff_evals: &[EF],
        coins: &[EF],
        f_delegation: EF,
    ) -> EF {
        assert_eq!(coeff_evals.len(), self.num_ntt);
        assert_eq!(coins.len(), self.num_ntt);
        let eval = izip!(coeff_evals.iter(), coins.iter())
            .fold(EF::zero(), |acc, (coeff, coin)| acc + *coeff * *coin);
        f_delegation * eval
    }

    /// Compute the randomized claimed sum in this sumcheck protocol, each sum is the evaluation of the involved point-MLE.
    /// Note that the evaluated point is the random point sampled before the sumcheck protocol,
    #[inline]
    pub fn compute_subclaim_sum<EF: AbstractExtensionField<F>>(
        &self,
        point_evals: &[EF],
        coins: &[EF],
    ) -> EF {
        assert_eq!(point_evals.len(), self.num_ntt);
        assert_eq!(coins.len(), self.num_ntt);
        izip!(point_evals.iter(), coins.iter())
            .fold(EF::zero(), |acc, (point, coin)| acc + *point * *coin)
    }

    /// Verify the subclaim using the evalustions sent by the prover instead of the whole MLEs.
    ///
    /// # Argument
    ///
    /// * `coeff_evals`: vector consisting of all the evaluations of relevant coeff-MLEs. The arrangement is consistent to the vector returned in `compute_coeff_evals`.
    /// * `point_evals`: vector consisting of all the evaluations of relevant point-MLEs. The arrangement is consistent to the vector returned in `compute_point_evals`.
    /// * `f_delegation`: evaluation of F(u, v) computed by prover
    /// * `coins`: random coins used to randomize ntt instances / sub-sumcheck protocols with linear combination
    /// * `subclaim`: subclaim returned from the randomized sumcheck protocol
    /// * `claimed_sum`: sum claimed by the prover
    #[inline]
    pub fn verify_subclaim<EF: AbstractExtensionField<F>>(
        &self,
        coeff_evals: &[EF],
        point_evals: &[EF],
        f_delegation: EF,
        coins: &[EF],
        subclaim: &SubClaim<F, EF>,
        claimed_sum: EF,
    ) -> bool {
        assert_eq!(coeff_evals.len(), self.num_ntt);
        assert_eq!(point_evals.len(), self.num_ntt);
        assert_eq!(coins.len(), self.num_ntt);

        // check 1: evaluation of the polynomial proved in the sumcheck protocol
        if self.compute_subclaim_eval(coeff_evals, coins, f_delegation)
            != subclaim.expected_evaluations
        {
            return false;
        }

        // check 2: evaluation of the randomized claimed sum
        self.compute_subclaim_sum(point_evals, coins) == claimed_sum
    }
}

impl<F: Field + Serialize> Serialize for NTTInstanceInfo<F> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.ntt_table.len() + 1))?;
        seq.serialize_element(&self.log_n)?;
        for e in self.ntt_table.iter() {
            seq.serialize_element(e)?;
        }
        seq.end()
    }
}
/// store the intermediate mles generated in each iteration in the `init_fourier_table_overall` algorithm
pub struct IntermediateMLEs<F: Field, EF: AbstractExtensionField<F>> {
    f_mles: Vec<Rc<DenseMultilinearExtension<F, EF>>>,
    w_mles: Vec<Rc<DenseMultilinearExtension<F, EF>>>,
}

impl<F: Field, EF: AbstractExtensionField<F>> IntermediateMLEs<F, EF> {
    /// Initiate the vector
    pub fn new(n_rounds: u32) -> Self {
        IntermediateMLEs {
            f_mles: Vec::with_capacity(n_rounds as usize),
            w_mles: Vec::with_capacity(n_rounds as usize),
        }
    }

    /// Add the intermediate mles generated in each round
    pub fn add_round_mles(&mut self, num_vars: usize, f_mle: &[EF], w_mle: Vec<EF>) {
        self.f_mles
            .push(Rc::new(DenseMultilinearExtension::from_evaluations_slice(
                num_vars, f_mle,
            )));
        self.w_mles
            .push(Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                num_vars, w_mle,
            )));
    }
}

/// Generate MLE for the Fourier function F(u, x) for x \in \{0, 1\}^dim where u is the random point.
/// Dynamic programming implementaion for initializing F(u, x) in NTT (derived from zkCNN: https://eprint.iacr.org/2021/673)
/// `N` is the dimension of the vector used to represent the polynomial in NTT.
///
/// In NTT, the Fourier matrix is different since we choose these points: ω^1, ω^3, ..., ω^{2N-1}
/// Compared to the original induction, the main differences here are F(y, x)  = ω^{(2Y+1) * X} and Y = \sum_{i = 0} y_i * 2^i.
/// The latter one indicates that we use little-endian.
/// As a result, the equation (8) in zkCNN is F(u, x) = ω^X * \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X})
///
/// In order to delegate the computation F(u, v) to prover, we decompose the ω^X term into the grand product.
/// Hence, the final equation is F(u, x) = \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X}) * ω^{2^i * x_i}
///
/// * In order to comprehend this implementation, it is strongly recommended to read the pure version `naive_init_fourier_table` and `init_fourier_table` in the `ntt_bare.rs`.
///   `naive_init_fourier_table` shows the original formula of this algorithm.
///   `init_fourier_table` shows the dynamic programming version of this algorithm.
///   `init_fourier_table_overall` (this function) stores many intermediate evaluations for the ease of the delegation of F(u, v)
///
/// # Arguments
/// * u: the random point
/// * ntt_table: It stores the NTT table: ω^0, ω^1, ..., ω^{2N - 1}
pub fn init_fourier_table_overall<F: Field, EF: AbstractExtensionField<F>>(
    u: &[EF],
    ntt_table: &[F],
) -> IntermediateMLEs<F, EF> {
    let log_n = u.len(); // N = 1 << dim
    let m = ntt_table.len(); // M = 2N = 2 * (1 << dim)

    // It store the evaluations of all F(u, x) for x \in \{0, 1\}^dim.
    // Note that in our implementation, we use little endian form, so the index `0b1011`
    // represents the point `P(1,1,0,1)` in {0,1}^`dim`
    let mut evaluations: Vec<_> = vec![EF::zero(); 1 << log_n];
    evaluations[0] = EF::one();

    // stores all the intermediate evaluations of the table (i.e. F(u, x)) and the term ω^{2^{i + 1} * X} in each iteration
    let mut intermediate_mles = <IntermediateMLEs<F, EF>>::new(log_n as u32);

    // * Compute \prod_{i=0}^{\log{N-1}} ((1 - u_i) + u_i * ω^{2^{i + 1} * X}) * ω^{2^i * x_i}
    // The reason why we update the table with u_i in reverse order is that
    // in round i, ω^{2^{i + 1} is the (M / (2^{i+1}))-th root of unity, e.g. i = dim - 1, ω^{2^{i + 1} is the 2-th root of unity.
    // Hence, we need to align this with the update method in dynamic programming.
    //
    // Note that the last term ω^{2^i * x_i} is indeed multiplied in the normal order, from x_0 to x_{log{n-1}}
    // since we actually iterate from the LSB to MSB  when updating the table from size 1, 2, 4, 8, ..., n in dynamic programming.
    for i in (0..log_n).rev() {
        // i starts from log_n - 1 and ends to 0
        let this_round_dim = log_n - i;
        let last_round_dim = this_round_dim - 1;
        let this_round_table_size = 1 << this_round_dim;
        let last_round_table_size = 1 << last_round_dim;

        let mut evaluations_w_term = vec![EF::zero(); this_round_table_size];
        for x in (0..this_round_table_size).rev() {
            // idx is to indicate the power ω^{2^{i + 1} * X} in ntt_table
            let idx = (1 << (i + 1)) * x % m;
            // the bit index in this iteration is last_round_dim = this_round_dim - 1
            // If x >= last_round_table_size, meaning the bit = 1, we need to multiply by ω^{2^last_round_dim * 1}
            if x >= last_round_table_size {
                evaluations[x] = evaluations[x % last_round_table_size]
                    * (EF::one() - u[i] + u[i] * ntt_table[idx])
                    * ntt_table[1 << last_round_dim];
            }
            // the bit index in this iteration is last_round_dim = this_round_dim - 1
            // If x < last_round_table_size, meaning the bit = 0, we do not need to multiply because ω^{2^last_round_dim * 0} = 1
            else {
                evaluations[x] = evaluations[x % last_round_table_size]
                    * (EF::one() - u[i] + u[i] * ntt_table[idx]);
            }
            evaluations_w_term[x] = EF::from_base(ntt_table[idx]);
        }
        intermediate_mles.add_round_mles(
            this_round_dim,
            &evaluations[..this_round_table_size],
            evaluations_w_term,
        );
    }

    intermediate_mles
}

/// Naive implementation for computing the MLE: w^{2^exp \cdot x} for x \in \{0, 1\}^x_dim in a naive method
///
/// # Arguments:
///
/// * ntt_table: NTT table for w (M-th root of unity) containing {1, w, w^1, ..., w^{M-1}}
/// * log_m: log of M
/// * x_dim: dimension of x or the num of variables of the outputted mle
/// * exp: the exponent of the function defined above
pub fn naive_w_power_times_x_table<F: Field, EF: AbstractExtensionField<F>>(
    ntt_table: &[F],
    log_m: usize,
    x_dim: usize,
    exp: usize,
) -> DenseMultilinearExtension<F, EF> {
    let m = 1 << log_m; // M = 2N = 2 * (1 << dim)
    assert_eq!(ntt_table.len(), m);

    let mut evaluations: Vec<_> = (0..(1 << x_dim)).map(|_| EF::one()).collect();
    for x in 0..(1 << x_dim) {
        evaluations[x] = EF::from_base(ntt_table[(1 << exp) * x % m]);
    }
    DenseMultilinearExtension::from_evaluations_vec(x_dim, evaluations)
}

/// Evaluate the mle w^{2^exp * x} for a random point r \in F^{x_dim}
/// This formula is also derived from the techniques in zkCNN: https://eprint.iacr.org/2021/673.
/// w^{2^exp * r} = \sum_x eq(x, r) *  w^{2^exp * x}
///               = \prod_i (1 - r_i + r_i * w^{2^ {(exp + i) % log_m})
/// * Note that the above equation only holds for exp <= logM - x_dim;
/// * otherwise, the exponent 2^exp * x involves a modular addition, disabling the decomposition.
///   (Although I am not clearly making it out, the experiement result shows the above argument.)
///
/// # Arguments:
///
/// * ntt_table: NTT table for w (M-th root of unity) containing {1, w, w^1, ..., w^{M-1}}
/// * log_m: log of M
/// * x_dim: dimension of x or the num of variables of the outputted mle
/// * exp: the exponent of the function defined above
/// * r: random point in F^{x_dim}
pub fn eval_w_power_times_x<F: Field, EF: AbstractExtensionField<F>>(
    ntt_table: &[F],
    log_m: usize,
    x_dim: usize,
    exp: usize,
    r: &[EF],
) -> EF {
    assert_eq!(ntt_table.len(), 1 << log_m);
    assert_eq!(x_dim, r.len());
    assert!(exp + x_dim <= log_m);
    let mut prod = EF::one();

    for (i, &r_i) in r.iter().enumerate() {
        let log_exp = (exp + i) % log_m;
        prod *= EF::one() - r_i + r_i * ntt_table[1 << log_exp];
    }

    prod
}

impl<F: Field> NTTInstance<F> {
    /// Extract the information of the NTT Instance for verification
    #[inline]
    pub fn info(&self) -> NTTInstanceInfo<F> {
        NTTInstanceInfo {
            num_ntt: 1,
            log_n: self.log_n,
            ntt_table: Rc::clone(&self.ntt_table),
        }
    }

    /// Constuct a new instance from vector
    #[inline]
    pub fn from_vec(
        log_n: usize,
        ntt_table: &Rc<Vec<F>>,
        coeffs: DenseMultilinearExtensionBase<F>,
        points: DenseMultilinearExtensionBase<F>,
    ) -> Self {
        Self {
            log_n,
            ntt_table: ntt_table.clone(),
            coeffs,
            points,
        }
    }

    /// Constuct a new instance from slice
    #[inline]
    pub fn from_slice(
        log_n: usize,
        ntt_table: &Rc<Vec<F>>,
        coeffs: &Rc<DenseMultilinearExtensionBase<F>>,
        points: &Rc<DenseMultilinearExtensionBase<F>>,
    ) -> Self {
        Self {
            log_n,
            ntt_table: ntt_table.clone(),
            coeffs: coeffs.as_ref().clone(),
            points: points.as_ref().clone(),
        }
    }

    /// Constuct a new instance from given info
    #[inline]
    pub fn from_info(info: &NTTInstanceInfo<F>) -> Self {
        Self {
            log_n: info.log_n,
            ntt_table: info.ntt_table.to_owned(),
            coeffs: <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(
                info.log_n,
                vec![F::zero(); 1 << info.log_n],
            ),
            points: <DenseMultilinearExtensionBase<F>>::from_evaluations_vec(
                info.log_n,
                vec![F::zero(); 1 << info.log_n],
            ),
        }
    }

    /// add ntt_instance
    #[inline]
    pub fn add_ntt(
        &mut self,
        r: F,
        coeffs: &Rc<DenseMultilinearExtensionBase<F>>,
        points: &Rc<DenseMultilinearExtensionBase<F>>,
    ) {
        self.coeffs += (r, coeffs);
        self.points += (r, points);
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> NTTSubclaim<F, EF> {
    /// verify the subcliam
    #[inline]
    pub fn verify_subcliam(
        &self,
        points: &DenseMultilinearExtension<F, EF>,
        coeffs: &DenseMultilinearExtension<F, EF>,
        u: &[EF],
        info: &NTTInstanceInfo<F>,
    ) -> bool {
        assert_eq!(u.len(), info.log_n);

        // check1: check the subclaim for ntt bare, i.e. $$a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) }$$
        // Note that the verifier delegates the computation F(u, v) to prover, so F(u, v) is included.
        if !self.ntt_bare_subclaim.verify_subclaim_with_delegation(
            self.delegation_first_claim,
            points,
            coeffs,
            u,
        ) {
            return false;
        }

        // check2: check the final claim returned from the last round of delegation
        let idx = 1 << (info.log_n);
        let eval = eval_identity_function(&self.final_point, &[EF::zero()])
            + eval_identity_function(&self.final_point, &[EF::one()])
                * (EF::one() - u[info.log_n - 1] + u[info.log_n - 1] * info.ntt_table[idx])
                * info.ntt_table[1];

        self.delegation_final_claim == eval
    }
}

impl<F: Field, EF: AbstractExtensionField<F>> NTTIOP<F, EF> {
    /// The delegation of F(u, v) consists of logN - 1 rounds, each of which is a sumcheck protocol.
    ///
    /// We define $A_{F}^{(k)}:\{0,1\}^{k+1} -> \mathbb{F}$ and $ω^{(k)}_{i+1}:\{0,1\}^{k+1} -> \mathbb{F}$.
    /// The prover asserts the following sum = \tilde{A}_{F}^{(k)}(x, b) at a random point $(x, b)\in \mathbb{F}^{k+1}$:
    /// sum = \sum_{z\in \{0,1\}}^k
    ///         \tilde{\beta}((x, b),(z,0)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 0)
    ///       + \tilde{\beta}((x, b),(z,1)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 1) * ω^{2^k}
    /// where $\ω^{(k)}_{i+1}(x,b ) = \ω^{2^{i+1}\cdot j}$ for $j = X+2^{i+1}\cdot b$.
    ///
    /// In the term of the data structure, the polynomial to be sumed can be viewed as the sum of two products,
    /// one has coefficient one, and the other has coefficient ω^{2^k}.
    ///
    /// # Arguments
    /// * round: round number denoted by k, which is iterated in a reverse order as described in the algorithm
    /// * point: the random point $(x, b)\in \mathbb{F}^{k+1}$ reduced from the last sumcheck, used to prove the sum in the round
    /// * u_i: parameter in this round as described in the formula
    /// * w_coeff: the coefficient ω^{2^k} of the second product
    /// * f: MLE \tilde{A}_{F}^{(k-1)}(z) for z\in \{0,1\}^k
    /// * w: MLE \tilde{ω}^{(k)}_{i+1}(z, b) for z\in \{0,1\}^k  and b\in \{0, 1\}, which will be divided into two smaller MLEs \tilde{ω}^{(k)}_{i+1}(z, 0) and \tilde{ω}^{(k)}_{i+1}(z, 1)
    pub fn delegation_prover_round(
        trans: &mut Transcript<F>,
        round: usize,
        point: &[EF],
        u_i: EF,
        w_coeff: EF,
        f: &Rc<DenseMultilinearExtension<F, EF>>,
        w: &Rc<DenseMultilinearExtension<F, EF>>,
    ) -> (Proof<F, EF>, ProverState<F, EF>) {
        assert_eq!(f.num_vars, round);
        assert_eq!(w.num_vars, round + 1);

        let mut poly = <ListOfProductsOfPolynomials<F, EF>>::new(round);

        // the equality function defined by the random point $(x, b)\in \mathbb{F}^{k+1}$
        // it is divided into two MLEs \tilde{\beta}((x, b),(z,0)) and \tilde{\beta}((x, b),(z,1))
        let eq_func = gen_identity_evaluations(point);
        let (eq_func_left, eq_func_right) = eq_func.split_halves();

        // two divided MLEs: \tilde{ω}^{(k)}_{i+1}(z, 0) and \tilde{ω}^{(k)}_{i+1}(z, 1)
        let (w_left, w_right) = w.split_halves();

        // construct the polynomial to be sumed
        // left product is \tilde{\beta}((x, b),(z,0)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 0)
        // right product is \tilde{\beta}((x, b),(z,1)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 1) * ω^{2^k}
        poly.add_product_with_linear_op(
            [Rc::new(eq_func_left), Rc::clone(f), Rc::new(w_left)],
            &[
                (UF::one(), UF::zero()),
                (UF::one(), UF::zero()),
                (UF::ExtensionField(u_i), UF::ExtensionField(EF::one() - u_i)),
            ],
            EF::one(),
        );

        poly.add_product_with_linear_op(
            [Rc::new(eq_func_right), Rc::clone(f), Rc::new(w_right)],
            &[
                (UF::one(), UF::zero()),
                (UF::one(), UF::zero()),
                (UF::ExtensionField(u_i), UF::ExtensionField(EF::one() - u_i)),
            ],
            w_coeff,
        );

        MLSumcheck::prove(trans, &poly).expect("ntt proof of delegation failed in round {round}")
    }

    /// Compared to the `prove` functionality, we just remove the phase to prove NTT bare.
    ///
    /// * `ntt_bare_state`: stores the prover state after proving the NTT bare
    pub fn prove_recursive(
        trans: &mut Transcript<F>,
        ntt_instance: &NTTInstanceExt<F, EF>,
        u: &[EF],
        ntt_bare_state: &ProverState<F, EF>,
    ) -> NTTRecursiveProof<F, EF> {
        trans.append_message(b"ntt", &ntt_instance.info());
        let log_n = ntt_instance.log_n;

        let intermediate_mles = init_fourier_table_overall(u, &ntt_instance.ntt_table);
        let (f_mles, w_mles) = (intermediate_mles.f_mles, intermediate_mles.w_mles);

        // 1. (detached) prove a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) } for a random point u

        // the above sumcheck is reduced to prove F(u, v) where v is the requested point
        // Note that the delegated value F(u, v) is stored in proof.delegation_claimed_sums[0].
        let mut requested_point = ntt_bare_state.randomness.clone();
        let mut reduced_claim = f_mles[log_n - 1].evaluate(&requested_point);

        // 2. prove the computation of F(u, v) in log_n - 1 rounds

        // store the sumcheck proof in each round
        let mut delegation_sumcheck_msgs = Vec::with_capacity(log_n - 1);
        // store the claimed sum of the sumcheck protocol in each round
        let mut delegation_claimed_sums = Vec::with_capacity(log_n - 1);
        for k in (1..log_n).rev() {
            // start form log_n - 1;
            let i = log_n - 1 - k;
            delegation_claimed_sums.push(reduced_claim);

            let w_coeff = ntt_instance.ntt_table[1 << k];
            let f = &f_mles[k - 1];
            let (proof_round, state_round) = Self::delegation_prover_round(
                trans,
                k,
                &requested_point,
                u[i],
                EF::from_base(w_coeff),
                f,
                &w_mles[k],
            );
            delegation_sumcheck_msgs.push(proof_round);

            // the requested point returned from this round of sumcheck protocol, which initiates the claimed sum of the next round
            requested_point = state_round.randomness;
            reduced_claim = f.evaluate(&requested_point);
        }

        NTTRecursiveProof {
            delegation_sumcheck_msgs,
            delegation_claimed_sums,
            final_claim: reduced_claim,
        }
    }

    /// prove NTT with delegation
    /// Note that this is the only interface that requires prover to provide an instance over Extension Field.
    /// We deliberately design in this way since the final NTT instance proved in our scheme is a randomized ntt instance defined over EF.
    pub fn prove(
        trans: &mut Transcript<F>,
        ntt_instance: &NTTInstanceExt<F, EF>,
        u: &[EF],
    ) -> NTTProof<F, EF> {
        trans.append_message(b"ntt", &ntt_instance.info());
        let log_n = ntt_instance.log_n;

        let intermediate_mles = init_fourier_table_overall(u, &ntt_instance.ntt_table);
        let (f_mles, w_mles) = (intermediate_mles.f_mles, intermediate_mles.w_mles);

        // 1. prove a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) } for a random point u
        let f_u = &f_mles[log_n - 1];
        let (ntt_bare_proof, state) = NTTBareIOP::prove(trans, f_u, ntt_instance, u);

        // the above sumcheck is reduced to prove F(u, v) where v is the requested point
        let mut requested_point = state.randomness;
        let mut reduced_claim = f_mles[log_n - 1].evaluate(&requested_point);

        // 2. prove the computation of F(u, v) in log_n - 1 rounds

        // store the sumcheck proof in each round
        let mut delegation_sumcheck_msgs = Vec::with_capacity(log_n - 1);
        // store the claimed sum of the sumcheck protocol in each round
        let mut delegation_claimed_sums = Vec::with_capacity(log_n - 1);
        for k in (1..log_n).rev() {
            // start form log_n - 1;
            let i = log_n - 1 - k;
            delegation_claimed_sums.push(reduced_claim);

            let w_coeff = ntt_instance.ntt_table[1 << k];
            let f = &f_mles[k - 1];
            let (proof_round, state_round) = Self::delegation_prover_round(
                trans,
                k,
                &requested_point,
                u[i],
                EF::from_base(w_coeff),
                f,
                &w_mles[k],
            );
            delegation_sumcheck_msgs.push(proof_round);

            // the requested point returned from this round of sumcheck protocol, which initiates the claimed sum of the next round
            requested_point = state_round.randomness;
            reduced_claim = f.evaluate(&requested_point);
        }

        NTTProof {
            ntt_bare_proof,
            delegation_sumcheck_msgs,
            delegation_claimed_sums,
            final_claim: reduced_claim,
        }
    }

    /// The delegation of F(u, v) consists of logN - 1 rounds, each of which is a sumcheck protocol.
    ///
    /// We define $A_{F}^{(k)}:\{0,1\}^{k+1} -> \mathbb{F}$ and $ω^{(k)}_{i+1}:\{0,1\}^{k+1} -> \mathbb{F}$.
    /// The prover asserts the following sum = \tilde{A}_{F}^{(k)}(x, b) at a random point $(x, b)\in \mathbb{F}^{k+1}$:
    /// sum = \sum_{z\in \{0,1\}}^k
    ///         \tilde{\beta}((x, b),(z,0)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 0)
    ///       + \tilde{\beta}((x, b),(z,1)) * \tilde{A}_{F}^{(k-1)}(z) ( (1-u_{i})+u_{i} * \tilde{ω}^{(k)}_{i+1}(z, 1) * ω^{2^k}
    /// where $\ω^{(k)}_{i+1}(x,b ) = \ω^{2^{i+1}\cdot j}$ for $j = X+2^{i+1}\cdot b$.
    ///
    /// The verify needs to check the equality of the evaluation of the polynomial to be summed at a random point z = r \in \{0,1\}}^k.
    /// In verification, the verifier is given the evaluation of \tilde{A}_{F}^{(k-1)}(z = r) instead of computing on his own, so he can use it to check.
    /// If the equality holds, it is reduced to check the evaluation of \tilde{A}_{F}^{(k-1)}(z = r).
    ///
    /// # Arguments
    /// * round: round number denoted by k, which is iterated in a reverse order as described in the algorithm
    /// * x_b_point: the random point $(x, b)\in \mathbb{F}^{k+1}$ reduced from the last sumcheck
    /// * u_i: parameter in this round as described in the formula
    /// * subclaim: the subclaim returned from this round of the sumcheck, containing the random point r used for equality check
    /// * reduced_claim: the given evaluation of \tilde{A}_{F}^{(k-1)}(z = r) so verify does not need to compute on his own
    pub fn delegation_verify_round(
        round: usize,
        x_b_point: &[EF],
        u_i: EF,
        subclaim: &SubClaim<F, EF>,
        reduced_claim: EF,
        ntt_instance_info: &NTTInstanceInfo<F>,
    ) -> bool {
        let log_n = ntt_instance_info.log_n;
        let ntt_table = &ntt_instance_info.ntt_table;

        // r_left = (r, 0) and r_right = (r, 0)
        let mut r_left = Vec::with_capacity(round + 1);
        let mut r_right = Vec::with_capacity(round + 1);
        r_left.extend(&subclaim.point);
        r_right.extend(&subclaim.point);
        r_left.push(EF::zero());
        r_right.push(EF::one());

        // compute $\ω^{(k)}_{i+1}(x,b ) = \ω^{2^{i+1}\cdot j}$ for $j = X+2^{i+1}\cdot b$ at point (r, 0) and (r, 1)
        // exp: i + 1 = n - k
        let exp = log_n - round;
        // w_left = \tilde{ω}^{(k)}_{i+1}(r, 0) and w_right = \tilde{ω}^{(k)}_{i+1}(r, 0)
        let w_left = eval_w_power_times_x(ntt_table, log_n + 1, round + 1, exp, &r_left);
        let w_right = eval_w_power_times_x(ntt_table, log_n + 1, round + 1, exp, &r_right);

        let eval = eval_identity_function(x_b_point, &r_left)
            * reduced_claim
            * (EF::one() - u_i + u_i * w_left)
            + eval_identity_function(x_b_point, &r_right)
                * reduced_claim
                * (EF::one() - u_i + u_i * w_right)
                * ntt_table[1 << round];

        eval == subclaim.expected_evaluations
    }

    /// Compared to the `prove` functionality, we remove the phase to prove NTT bare.
    /// Also, after detaching the verfication of NTT bare, verifier can directly check the recursive proofs.
    pub fn verify_recursive(
        trans: &mut Transcript<F>,
        proof: &NTTRecursiveProof<F, EF>,
        info: &NTTInstanceInfo<F>,
        u: &[EF],
        subclaim: &SubClaim<F, EF>,
    ) -> bool {
        trans.append_message(b"ntt", info);
        let log_n = info.log_n;
        assert_eq!(proof.delegation_sumcheck_msgs.len(), log_n - 1);
        assert_eq!(proof.delegation_claimed_sums.len(), log_n - 1);

        // 1. [detached] verify a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) } for a random point u
        // Note that the delegated value F(u, v) is stored in proof.delegation_claimed_sums[0].

        // 2. verify the computation of F(u, v) in log_n - 1 rounds
        let mut requested_point = subclaim.point.clone();
        for (cnt, k) in (1..log_n).rev().enumerate() {
            let i = log_n - 1 - k;

            // verify the proof of the sumcheck protocol
            let poly_info = PolynomialInfo {
                max_multiplicands: 3,
                num_variables: k,
            };
            let subclaim = MLSumcheck::verify(
                trans,
                &poly_info,
                proof.delegation_claimed_sums[cnt],
                &proof.delegation_sumcheck_msgs[cnt],
            )
            .expect("ntt verification failed in round {cnt}");

            // In the last round of the sumcheck protocol, the verify needs to check the equality of the evaluation of the polynomial to be summed at a random point z = r \in \{0,1\}}^k.
            // The verifier is given the evaluation of \tilde{A}_{F}^{(k-1)}(z = r) instead of computing on his own, so he can use it to check.
            // If the equality holds, it is reduced to check the evaluation of \tilde{A}_{F}^{(k-1)}(z = r).
            let reduced_claim = if cnt < log_n - 2 {
                proof.delegation_claimed_sums[cnt + 1]
            } else {
                proof.final_claim
            };
            // check the equality
            if !Self::delegation_verify_round(
                k,
                &requested_point,
                u[i],
                &subclaim,
                reduced_claim,
                info,
            ) {
                panic!("ntt verification failed in round {cnt}");
            }
            requested_point = subclaim.point;
        }

        let delegation_final_claim = proof.final_claim;
        let final_point = requested_point;
        // TODO: handle the case that log = 1
        assert_eq!(final_point.len(), 1);

        // check the final claim returned from the last round of delegation
        let idx = 1 << (info.log_n);
        let eval = eval_identity_function(&final_point, &[EF::zero()])
            + eval_identity_function(&final_point, &[EF::one()])
                * (EF::one() - u[info.log_n - 1] + u[info.log_n - 1] * info.ntt_table[idx])
                * info.ntt_table[1];

        delegation_final_claim == eval
    }

    /// verify NTT with delegation
    pub fn verify(
        trans: &mut Transcript<F>,
        proof: &NTTProof<F, EF>,
        ntt_instance_info: &NTTInstanceInfo<F>,
        u: &[EF],
    ) -> NTTSubclaim<F, EF> {
        trans.append_message(b"ntt", ntt_instance_info);
        let log_n = ntt_instance_info.log_n;
        assert_eq!(proof.delegation_sumcheck_msgs.len(), log_n - 1);
        assert_eq!(proof.delegation_claimed_sums.len(), log_n - 1);

        // 1. verify a(u) = \sum_{x\in \{0, 1\}^{\log N} c(x)\cdot F(u, x) } for a random point u
        let ntt_bare_subclaim = NTTBareIOP::verify(trans, &proof.ntt_bare_proof, ntt_instance_info);

        // 2. verify the computation of F(u, v) in log_n - 1 rounds
        let mut requested_point = ntt_bare_subclaim.point.clone();
        for (cnt, k) in (1..log_n).rev().enumerate() {
            let i = log_n - 1 - k;

            // verify the proof of the sumcheck protocol
            let poly_info = PolynomialInfo {
                max_multiplicands: 3,
                num_variables: k,
            };
            let subclaim = MLSumcheck::verify(
                trans,
                &poly_info,
                proof.delegation_claimed_sums[cnt],
                &proof.delegation_sumcheck_msgs[cnt],
            )
            .expect("ntt verification failed in round {cnt}");

            // In the last round of the sumcheck protocol, the verify needs to check the equality of the evaluation of the polynomial to be summed at a random point z = r \in \{0,1\}}^k.
            // The verifier is given the evaluation of \tilde{A}_{F}^{(k-1)}(z = r) instead of computing on his own, so he can use it to check.
            // If the equality holds, it is reduced to check the evaluation of \tilde{A}_{F}^{(k-1)}(z = r).
            let reduced_claim = if cnt < log_n - 2 {
                proof.delegation_claimed_sums[cnt + 1]
            } else {
                proof.final_claim
            };
            // check the equality
            if !Self::delegation_verify_round(
                k,
                &requested_point,
                u[i],
                &subclaim,
                reduced_claim,
                ntt_instance_info,
            ) {
                panic!("ntt verification failed in round {cnt}");
            }
            requested_point = subclaim.point;
        }

        // TODO: handle the case that log = 1
        assert_eq!(requested_point.len(), 1);
        NTTSubclaim {
            ntt_bare_subclaim,
            delegation_first_claim: proof.delegation_claimed_sums[0],
            delegation_final_claim: proof.final_claim,
            final_point: requested_point,
        }
    }
}

#[cfg(test)]
mod test {
    use crate::piop::ntt::{eval_w_power_times_x, naive_w_power_times_x_table};
    use algebra::{
        derive::{DecomposableField, FheField, Field, Prime, NTT},
        BabyBear, BabyBearExetension, DecomposableField, DenseMultilinearExtensionBase, Field,
        FieldUniformSampler, MultilinearExtension, NTTField,
    };
    use num_traits::{One, Zero};
    use rand::thread_rng;
    use rand_distr::Distribution;

    use super::init_fourier_table_overall;

    #[derive(Field, DecomposableField, FheField, Prime, NTT)]
    #[modulus = 2013265921]
    pub struct Fp32(u64);
    // field type
    type FF = BabyBear;
    type EF = BabyBearExetension;

    #[test]
    fn test_init_fourier_table_overall() {
        let sampler = <FieldUniformSampler<EF>>::new();
        let mut rng = thread_rng();

        let dim = 10;
        let m = 1 << (dim + 1); // M = 2N = 2 * (1 << dim)
        let u: Vec<_> = (0..dim).map(|_| sampler.sample(&mut rng)).collect();
        let v: Vec<_> = (0..dim).map(|_| sampler.sample(&mut rng)).collect();

        let mut u_v: Vec<EF> = Vec::with_capacity(dim << 1);
        u_v.extend(&u);
        u_v.extend(&v);

        // root is the M-th root of unity
        let root = Fp32::try_minimal_primitive_root(m).unwrap();
        let root = FF::new(root.value() as u32);

        let mut fourier_matrix: Vec<_> = (0..(1 << dim) * (1 << dim)).map(|_| FF::zero()).collect();
        let mut ntt_table = Vec::with_capacity(m as usize);

        let mut power = FF::one();
        for _ in 0..m {
            ntt_table.push(power);
            power *= root;
        }

        // In little endian, the index for F[i, j] is i + (j << dim)
        for i in 0..1 << dim {
            for j in 0..1 << dim {
                let idx_power = (2 * i + 1) * j % m;
                let idx_fourier = i + (j << dim);
                fourier_matrix[idx_fourier as usize] = ntt_table[idx_power as usize];
            }
        }

        let fourier_mle =
            DenseMultilinearExtensionBase::from_evaluations_vec(dim << 1, fourier_matrix);
        let partial_fourier_mle = &init_fourier_table_overall(&u, &ntt_table).f_mles[dim - 1];

        assert_eq!(
            fourier_mle.evaluate_ext(&u_v),
            partial_fourier_mle.evaluate(&v)
        );
    }

    #[test]
    fn test_w_power_x() {
        let dim = 10; // meaning x\in \{0, 1\}^{dim} and N = 1 << dim
        let log_m = dim + 1;
        let m = 1 << log_m; // M = 2N

        // root is the M-th root of unity
        let root = Fp32::try_minimal_primitive_root(m).unwrap();
        let root = FF::new(root.value() as u32);

        let mut ntt_table = Vec::with_capacity(m as usize);

        let mut power = FF::one();
        for _ in 0..m {
            ntt_table.push(power);
            power *= root;
        }

        let sampler = <FieldUniformSampler<EF>>::new();
        let mut rng = thread_rng();

        for x_dim in 0..=dim {
            let max_exp = log_m - x_dim;
            for exp in 0..=max_exp {
                let r: Vec<_> = (0..x_dim).map(|_| sampler.sample(&mut rng)).collect();
                let w_mle = naive_w_power_times_x_table(&ntt_table, log_m, x_dim, exp);
                let w_eval = eval_w_power_times_x(&ntt_table, log_m, x_dim, exp, &r);
                assert_eq!(w_eval, w_mle.evaluate(&r));
            }
        }
    }
}
