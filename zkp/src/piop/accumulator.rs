//! IOP for Accumulator updating t times
//! ACC = ACC + (X^{-a_u} - 1) * ACC * RGSW(Z_u)
//! Each updation contains two single ntt operations and one multiplication between RLWE and RGSW
use crate::sumcheck::verifier::SubClaim;
use crate::sumcheck::MLSumcheck;
use crate::sumcheck::Proof;
use crate::utils::eval_identity_function;
use std::marker::PhantomData;
use std::rc::Rc;

use algebra::{
    DenseMultilinearExtension, Field, ListOfProductsOfPolynomials, MultilinearExtension,
    PolynomialInfo,
};
use itertools::izip;
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha12Rng;

use super::bit_decomposition::{BitDecomposition, BitDecompositionProof, BitDecompositionSubClaim};
use super::ntt::{NTTProof, NTTSubclaim};
use super::{DecomposedBits, DecomposedBitsInfo, NTTInstance, NTTInstanceInfo, NTTIOP};
use super::{RlweCiphertext, RlweCiphertexts};

/// SNARKs for Multiplication between RLWE ciphertext and RGSW ciphertext
pub struct AccumulatorIOP<F: Field>(PhantomData<F>);

/// proof generated by prover
pub struct AccumulatorProof<F: Field> {
    /// proof for bit decomposition
    pub bit_decomposition_proof: BitDecompositionProof<F>,
    /// proof for ntt
    pub ntt_proof: NTTProof<F>,
    /// proof for sumcheck
    pub sumcheck_msg: Proof<F>,
}

/// subclaim reutrned to verifier
pub struct AccumulatorSubclaim<F: Field> {
    /// subclaim returned from the Bit Decomposition IOP
    pub bit_decomposition_subclaim: BitDecompositionSubClaim<F>,
    /// subclaim returned from the NTT IOP
    pub ntt_subclaim: NTTSubclaim<F>,
    /// subclaim returned from the sumcheck protocol
    pub sumcheck_subclaim: SubClaim<F>,
}

/// accumulator witness when performing ACC = ACC + (X^{-a_u} + 1) * ACC * RGSW(Z_u)
pub struct AccumulatorWitness<F: Field> {
    /// * Witness when performing input_rlwe_ntt := (X^{-a_u} + 1) * ACC
    ///
    /// accumulator of ntt form
    pub accumulator_ntt: RlweCiphertext<F>,
    /// scalar d = (X^{-a_u} + 1) of coefficient form
    pub d: Rc<DenseMultilinearExtension<F>>,
    /// scalar d = (X^{-a_u} + 1) of ntt form
    pub d_ntt: Rc<DenseMultilinearExtension<F>>,
    /// result d * ACC of ntt form
    pub input_rlwe_ntt: RlweCiphertext<F>,
    /// * Witness when performing output_rlwe_ntt := input_rlwe * RGSW(Z_u) where input_rlwe = (X^{-a_u} + 1) * ACC
    ///
    /// result d * ACC of coefficient form
    ///
    /// rlwe = (a, b): store the input ciphertext (a, b) where a and b are two polynomials represented by N coefficients.
    pub input_rlwe: RlweCiphertext<F>,
    /// bits_rlwe = (a_bits, b_bits): a_bits (b_bits) corresponds to the bit decomposition result of a (b) in the input rlwe ciphertext
    pub bits_rlwe: RlweCiphertexts<F>,
    /// bits_rlwe_ntt: ntt form of the above bit decomposition result
    pub bits_rlwe_ntt: RlweCiphertexts<F>,
    /// bits_rgsw_c_ntt: the ntt form of the first part (c) in the RGSW ciphertext
    pub bits_rgsw_c_ntt: RlweCiphertexts<F>,
    /// bits_rgsw_c_ntt: the ntt form of the second part (f) in the RGSW ciphertext
    pub bits_rgsw_f_ntt: RlweCiphertexts<F>,
    /// output_rlwe_ntt: store the output ciphertext (g', h') in the NTT-form
    pub output_rlwe_ntt: RlweCiphertext<F>,
}

/// Store the ntt instance, bit decomposition instance, and the sumcheck instance for an Accumulator updating `t` times
pub struct AccumulatorInstance<F: Field> {
    /// number of updations in Accumulator denoted by t
    pub num_updations: usize,
    /// number of ntt transformation in Accumulator
    pub num_ntt: usize,
    /// the (virtually) randomized ntt instance to be proved
    pub ntt_instance: NTTInstance<F>,
    /// all decomposed bits
    pub decomposed_bits: DecomposedBits<F>,
    /// poly in the sumcheck instance
    pub poly: ListOfProductsOfPolynomials<F>,
}

/// Store the Accumulator info used to verify
pub struct AccumulatorInstanceInfo<F: Field> {
    /// number of updations in Accumulator denoted by t
    pub num_updations: usize,
    /// info to verify ntt
    pub ntt_info: NTTInstanceInfo<F>,
    /// info to verify bit decomposition
    pub decomposed_bits_info: DecomposedBitsInfo<F>,
    /// info to verify sumcheck
    pub poly_info: PolynomialInfo,
}

impl<F: Field> AccumulatorInstance<F> {
    /// construct an accumulator instance based on ntt info and bit-decomposition info
    #[inline]
    pub fn new(
        num_vars: usize,
        ntt_info: &NTTInstanceInfo<F>,
        decom_info: &DecomposedBitsInfo<F>,
    ) -> Self {
        Self {
            num_updations: 0,
            num_ntt: 0,
            ntt_instance: <NTTInstance<F>>::from_info(ntt_info),
            decomposed_bits: <DecomposedBits<F>>::from_info(decom_info),
            poly: <ListOfProductsOfPolynomials<F>>::new(num_vars),
        }
    }

    /// Extract the information
    #[inline]
    pub fn info(&self) -> AccumulatorInstanceInfo<F> {
        AccumulatorInstanceInfo {
            num_updations: self.num_updations,
            ntt_info: self.ntt_instance.info(),
            decomposed_bits_info: self.decomposed_bits.info(),
            poly_info: self.poly.info(),
        }
    }

    /// add witness
    ///
    /// # Arguments:
    /// * randomness_ntt: randomness used for integrating (2k+3) ntt instances into the target ntt instance
    /// * randomness_sumcheck: randomness used to integrating 2 sumcheck protocols
    /// * identity_func_at_u: identity function at the random point u where u is chosen for sumcheck protocol
    /// * witness: all intermediate witness when updating the accumulator once
    pub fn add_witness(
        &mut self,
        randomness_ntt: &[F],
        randomness_sumcheck: &[F],
        identity_func_at_u: &Rc<DenseMultilinearExtension<F>>,
        witness: &AccumulatorWitness<F>,
    ) {
        self.num_updations += 1;
        assert_eq!(
            randomness_ntt.len(),
            ((self.decomposed_bits.bits_len << 1) + 3) as usize
        );
        self.num_ntt += randomness_ntt.len();
        assert_eq!(randomness_sumcheck.len(), 2);

        // Integrate the Bit-Decomposition Part
        assert_eq!(
            witness.bits_rlwe.a_bits.len(),
            self.decomposed_bits.bits_len as usize
        );
        assert_eq!(
            witness.bits_rlwe.b_bits.len(),
            self.decomposed_bits.bits_len as usize
        );
        self.decomposed_bits
            .add_decomposed_bits_instance(&witness.bits_rlwe.a_bits);
        self.decomposed_bits
            .add_decomposed_bits_instance(&witness.bits_rlwe.b_bits);

        // Integrate the NTT Part
        let mut r = randomness_ntt.iter();
        self.ntt_instance
            .add_ntt(*r.next().unwrap(), &witness.d, &witness.d_ntt);
        self.ntt_instance.add_ntt(
            *r.next().unwrap(),
            &witness.input_rlwe.a,
            &witness.input_rlwe_ntt.a,
        );
        self.ntt_instance.add_ntt(
            *r.next().unwrap(),
            &witness.input_rlwe.b,
            &witness.input_rlwe_ntt.b,
        );

        // k ntt instances for a_i =NTT equal= a_i'
        for (coeffs, points) in izip!(&witness.bits_rlwe.a_bits, &witness.bits_rlwe_ntt.a_bits) {
            self.ntt_instance
                .add_ntt(*r.next().unwrap(), coeffs, points);
        }
        // k ntt instances for b_i =NTT equal= b_i'
        for (coeffs, points) in izip!(&witness.bits_rlwe.b_bits, &witness.bits_rlwe_ntt.b_bits) {
            self.ntt_instance
                .add_ntt(*r.next().unwrap(), coeffs, points);
        }

        // Integrate the Sumcheck Part
        let r_1 = randomness_sumcheck[0];
        let r_2 = randomness_sumcheck[1];
        // Sumcheck protocol for proving: g' = \sum_{i = 0}^{k-1} a_i' \cdot c_i + b_i' \cdot f_i
        // When proving g'(x) = \sum_{i = 0}^{k-1} a_i'(x) \cdot c_i(x) + b_i'(x) \cdot f_i(x) for x \in \{0, 1\}^\log n,
        // prover claims the sum \sum_{x} eq(u, x) (\sum_{i = 0}^{k-1} a_i'(x) \cdot c_i(x) + b_i'(x) \cdot f_i(x) - g'(x)) = 0
        // where u is randomly sampled by the verifier.
        for (a, b, c, f) in izip!(
            &witness.bits_rlwe_ntt.a_bits,
            &witness.bits_rlwe_ntt.b_bits,
            &witness.bits_rgsw_c_ntt.a_bits,
            &witness.bits_rgsw_f_ntt.a_bits
        ) {
            let prod1 = [Rc::clone(a), Rc::clone(c), Rc::clone(identity_func_at_u)];
            let prod2 = [Rc::clone(b), Rc::clone(f), Rc::clone(identity_func_at_u)];
            self.poly.add_product(prod1, r_1);
            self.poly.add_product(prod2, r_1);
        }
        // Sumcheck protocol for proving: h' = \sum_{i = 0}^{k-1} a_i' \cdot c_i' + b_i' \cdot f_i'
        for (a, b, c, f) in izip!(
            &witness.bits_rlwe_ntt.a_bits,
            &witness.bits_rlwe_ntt.b_bits,
            &witness.bits_rgsw_c_ntt.b_bits,
            &witness.bits_rgsw_f_ntt.b_bits
        ) {
            let prod1 = [Rc::clone(a), Rc::clone(c), Rc::clone(identity_func_at_u)];
            let prod2 = [Rc::clone(b), Rc::clone(f), Rc::clone(identity_func_at_u)];
            self.poly.add_product(prod1, r_2);
            self.poly.add_product(prod2, r_2);
        }

        self.poly.add_product(
            [
                Rc::clone(&witness.output_rlwe_ntt.a),
                Rc::clone(identity_func_at_u),
            ],
            -r_1,
        );
        self.poly.add_product(
            [
                Rc::clone(&witness.output_rlwe_ntt.b),
                Rc::clone(identity_func_at_u),
            ],
            -r_2,
        );
    }
}

impl<F: Field> AccumulatorIOP<F> {
    /// prove the accumulator updation
    pub fn prove(instance: &AccumulatorInstance<F>, u: &[F]) -> AccumulatorProof<F> {
        let seed: <ChaCha12Rng as SeedableRng>::Seed = Default::default();
        let mut fs_rng = ChaCha12Rng::from_seed(seed);
        Self::prove_as_subprotocol(&mut fs_rng, instance, u)
    }

    /// prove the accumulator updation
    pub fn prove_as_subprotocol(
        fs_rng: &mut impl RngCore,
        instance: &AccumulatorInstance<F>,
        u: &[F],
    ) -> AccumulatorProof<F> {
        AccumulatorProof {
            bit_decomposition_proof: BitDecomposition::prove_as_subprotocol(
                fs_rng,
                &instance.decomposed_bits,
                u,
            ),
            ntt_proof: NTTIOP::prove_as_subprotocol(fs_rng, &instance.ntt_instance, u),
            sumcheck_msg: MLSumcheck::prove_as_subprotocol(fs_rng, &instance.poly)
                .expect("sumcheck fail in accumulator updation")
                .0,
        }
    }

    /// verify the proof
    pub fn verify(
        proof: &AccumulatorProof<F>,
        u: &[F],
        info: &AccumulatorInstanceInfo<F>,
    ) -> AccumulatorSubclaim<F> {
        let seed: <ChaCha12Rng as SeedableRng>::Seed = Default::default();
        let mut fs_rng = ChaCha12Rng::from_seed(seed);
        Self::verify_as_subprotocol(&mut fs_rng, proof, u, info)
    }

    /// verify the proof with provided RNG
    pub fn verify_as_subprotocol(
        fs_rng: &mut impl RngCore,
        proof: &AccumulatorProof<F>,
        u: &[F],
        info: &AccumulatorInstanceInfo<F>,
    ) -> AccumulatorSubclaim<F> {
        AccumulatorSubclaim {
            bit_decomposition_subclaim: BitDecomposition::verify_as_subprotocol(
                fs_rng,
                &proof.bit_decomposition_proof,
                &info.decomposed_bits_info,
            ),
            ntt_subclaim: NTTIOP::verify_as_subprotocol(
                fs_rng,
                &proof.ntt_proof,
                &info.ntt_info,
                u,
            ),
            sumcheck_subclaim: MLSumcheck::verify_as_subprotocol(
                fs_rng,
                &info.poly_info,
                F::zero(),
                &proof.sumcheck_msg,
            )
            .expect("sumcheck protocol in rlwe mult rgsw failed"),
        }
    }
}

impl<F: Field> AccumulatorSubclaim<F> {
    /// verify the subclaim
    ///
    /// # Arguments
    /// * u: random point chosen by verifier
    /// * randomness_ntt: randomness used to combine ntt instances
    /// * randomness_sumecheck: randomness used to combine sumcheck protocols
    /// * ntt_coeffs: the final random ntt instance to be proved
    /// * ntt_points: the final random ntt instance to be proved
    /// * witness: all the winess when updating the accumulator
    /// * info: info used to verify
    #[allow(clippy::too_many_arguments)]
    pub fn verify_subclaim(
        &self,
        u: &[F],
        randomness_ntt: &[F],
        randomness_sumcheck: &[F],
        ntt_coeffs: &DenseMultilinearExtension<F>,
        ntt_points: &DenseMultilinearExtension<F>,
        witnesses: &Vec<AccumulatorWitness<F>>,
        info: &AccumulatorInstanceInfo<F>,
    ) -> bool {
        let num_ntt_instance =
            (info.num_updations as u32) * ((info.decomposed_bits_info.bits_len << 1) + 3);
        assert_eq!(randomness_ntt.len(), num_ntt_instance as usize);
        assert_eq!(u.len(), info.ntt_info.log_n);
        assert_eq!(randomness_sumcheck.len(), 2 * info.num_updations);

        // check 1: check the consistency of the randomized ntt instance and the original ntt instances
        let mut coeffs_eval = F::zero();
        let mut points_eval = F::zero();
        let mut r_iter = randomness_ntt.iter();

        for witness in witnesses {
            let r = r_iter.next().unwrap();
            coeffs_eval += *r * witness.d.evaluate(u);
            points_eval += *r * witness.d_ntt.evaluate(u);
            let r = r_iter.next().unwrap();
            coeffs_eval += *r * witness.input_rlwe.a.evaluate(u);
            points_eval += *r * witness.input_rlwe_ntt.a.evaluate(u);
            let r = r_iter.next().unwrap();
            coeffs_eval += *r * witness.input_rlwe.b.evaluate(u);
            points_eval += *r * witness.input_rlwe_ntt.b.evaluate(u);

            for (coeffs, points) in izip!(&witness.bits_rlwe.a_bits, &witness.bits_rlwe_ntt.a_bits)
            {
                let r = r_iter.next().unwrap();
                coeffs_eval += *r * coeffs.evaluate(u);
                points_eval += *r * points.evaluate(u);
            }

            for (coeffs, points) in izip!(&witness.bits_rlwe.b_bits, &witness.bits_rlwe_ntt.b_bits)
            {
                let r = r_iter.next().unwrap();
                coeffs_eval += *r * coeffs.evaluate(u);
                points_eval += *r * points.evaluate(u);
            }
        }
        if coeffs_eval != ntt_coeffs.evaluate(u) || points_eval != ntt_points.evaluate(u) {
            return false;
        }

        // TODO: For ease of implementation, we pass the resulting randomized ntt_instance but it can be omitted after combined with PCS.
        // check 2: check the subclaim returned from the ntt iop
        if !self
            .ntt_subclaim
            .verify_subcliam(ntt_points, ntt_coeffs, u, &info.ntt_info)
        {
            return false;
        }

        // check 3: check the subclaim returned from the bit decomposition iop
        let mut d_bits = Vec::with_capacity(2 * info.num_updations);
        let mut d_val = Vec::with_capacity(2 * info.num_updations);
        for witness in witnesses {
            d_bits.push(&witness.bits_rlwe.a_bits);
            d_bits.push(&witness.bits_rlwe.b_bits);
            d_val.push(Rc::clone(&witness.input_rlwe.a));
            d_val.push(Rc::clone(&witness.input_rlwe.b));
        }
        if !self.bit_decomposition_subclaim.verify_subclaim(
            &d_val,
            &d_bits,
            u,
            &info.decomposed_bits_info,
        ) {
            return false;
        }

        let mut r = randomness_sumcheck.iter();

        // 4. check 4: check the subclaim returned from the sumcheck protocol consisting of two sub-sumcheck protocols
        let mut sum_eval = F::zero();
        for witness in witnesses {
            let mut sum1_eval = F::zero();
            let mut sum2_eval = F::zero();
            // The first part is to evaluate at a random point g' = \sum_{i = 0}^{k-1} a_i' \cdot c_i + b_i' \cdot f_i
            // It is the reduction claim of prover asserting the sum \sum_{x} eq(u, x) (\sum_{i = 0}^{k-1} a_i'(x) \cdot c_i(x) + b_i'(x) \cdot f_i(x) - g'(x)) = 0
            // where u is randomly sampled by the verifier.
            for (a, b, c, f) in izip!(
                &witness.bits_rlwe_ntt.a_bits,
                &witness.bits_rlwe_ntt.b_bits,
                &witness.bits_rgsw_c_ntt.a_bits,
                &witness.bits_rgsw_f_ntt.a_bits
            ) {
                sum1_eval += (a.evaluate(&self.sumcheck_subclaim.point)
                    * c.evaluate(&self.sumcheck_subclaim.point))
                    + (b.evaluate(&self.sumcheck_subclaim.point)
                        * f.evaluate(&self.sumcheck_subclaim.point));
            }

            // The second part is to evaluate at a random point h' = \sum_{i = 0}^{k-1} a_i' \cdot c_i' + b_i' \cdot f_i'
            // It is the reduction claim of prover asserting the sum \sum_{x} eq(u, x) (\sum_{i = 0}^{k-1} a_i'(x) \cdot c_i'(x) + b_i'(x) \cdot f_i'(x) - g'(x)) = 0
            // where u is randomly sampled by the verifier.
            for (a, b, c, f) in izip!(
                &witness.bits_rlwe_ntt.a_bits,
                &witness.bits_rlwe_ntt.b_bits,
                &witness.bits_rgsw_c_ntt.b_bits,
                &witness.bits_rgsw_f_ntt.b_bits
            ) {
                sum2_eval += (a.evaluate(&self.sumcheck_subclaim.point)
                    * c.evaluate(&self.sumcheck_subclaim.point))
                    + (b.evaluate(&self.sumcheck_subclaim.point)
                        * f.evaluate(&self.sumcheck_subclaim.point));
            }

            let r_1 = r.next().unwrap();
            let r_2 = r.next().unwrap();
            sum_eval += eval_identity_function(u, &self.sumcheck_subclaim.point)
                * (*r_1
                    * (sum1_eval
                        - witness
                            .output_rlwe_ntt
                            .a
                            .evaluate(&self.sumcheck_subclaim.point))
                    + *r_2
                        * (sum2_eval
                            - witness
                                .output_rlwe_ntt
                                .b
                                .evaluate(&self.sumcheck_subclaim.point)))
        }
        sum_eval == self.sumcheck_subclaim.expected_evaluations
    }
}
